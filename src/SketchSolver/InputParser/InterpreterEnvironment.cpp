#include "InterpreterEnvironment.h"

#include <utility>
#include "InputReader.h"
#include "CallGraphAnalysis.h"
#include "DagFunctionToAssertion.h"
#include "Util.h"

#include "ArithmeticExpressionBuilder.h"
#include "SwapperPredicateBuilder.h"
#include "DeductiveSolver.h"
#include "IntToFloatRewriteDag.h"
#include "SolverLanguage.h"
#include "SketchFunction.h"
#include "ProgramEnvironment.h"

#ifdef CONST
#undef CONST
#endif



class Strudel {
	vector<Tvalue>& vals;
	SATSolver* solver;
	FloatManager& floats;
public:
	Strudel(vector<Tvalue>& vtv, SATSolver* solv, FloatManager& fm):vals(vtv), solver(solv), floats(fm){
		cout << "This is strange size=" << vtv.size() << endl;
	}


	int valueForINode(INTER_node* inode, VarStore& values, int& nbits) {
		Tvalue& tv = vals[inode->id];
		int retval = tv.eval(solver);
		{ cout << " input " << inode->get_name() << " has value " << retval << endl; }
		return retval;
	}

	void checker(BooleanDAG* dag, VarStore& values, bool_node::Type type) {
		cout << "Entering ~!" << endl;
		BooleanDAG* newdag = dag->clone();
		vector<bool_node*> inodeList = newdag->getNodesByType(type);

		// cout<<" * Specializing problem for "<<(type == bool_node::CTRL? "controls" : "inputs")<<endl; 
		cout << " * Before specialization: nodes = " << newdag->size() << " Ctrls = " << inodeList.size() << endl;
		{
			DagOptim cse(*newdag, floats);			

			BooleanDAG* cl = newdag->clone();
			for (int i = 0; i<newdag->size(); ++i) {
				// Get the code for this node.				
				if ((*newdag)[i] != nullptr) {
					if ((*newdag)[i]->type == bool_node::CTRL) {
						INTER_node* inode = dynamic_cast<INTER_node*>((*newdag)[i]);
						int nbits;
						int t = valueForINode(inode, values, nbits);
						bool_node * repl = nullptr;
						if (nbits == 1) {
							repl = cse.getCnode(t == 1);
						}
						else {
							repl = cse.getCnode(t);
						}
						Tvalue& tv = vals[i];
						cout << "ctrl=";
						tv.print(cout, solver);
						cout << endl;
						Assert((*newdag)[inode->id] == inode, "The numbering is wrong!!");
						newdag->replace(inode->id, repl);
					}
					else {
						bool_node* node = cse.computeOptim((*newdag)[i]);
						Tvalue& tv = vals[i];
						cout << " old = " << (*cl)[i]->lprint() << " new " << node->lprint() << "  ";
						tv.print(cout, solver);
						if (node->type == bool_node::CONST && cse.getIval(node) == tv.eval(solver)) {
							cout << " good";
						}
						else {
							cout << " bad";
						}
						cout << endl;

						if ((*newdag)[i] != node) {
							newdag->replace(i, node);
						}
					}
				}
			}
		}
	}

};





InterpreterEnvironment::~InterpreterEnvironment(void)
{
	for (auto it = functionMap.begin(); it != functionMap.end(); ++it) {
		it->second->clear();
	}
	if (bgproblem != NULL) {
		bgproblem->clear();
	}
	ArithExprBuilder::clearStaticMapMemory();
	SwapperPredicateNS::PredicateBuilder::clearStaticMapMemory();
    solver->clear();
    delete solver;
	delete finder;
	delete _pfind;
}

/* Runs the input command in interactive mode. 'cmd' can be:
* exit -- exits the solver
* print -- print the controls
* import -- read the file generated by the front-end
*/
int InterpreterEnvironment::runCommand(const string& cmd, list<string*>& parlist) {
	if (cmd == "exit") {
		return 0;
	}
	if (cmd == "print") {
		if (parlist.size() > 0) {
			printControls(*parlist.front());
			for (list<string*>::iterator it = parlist.begin(); it != parlist.end(); ++it) {
				delete *it;
			}
		}
		else {
			printControls("");
		}
		return -1;
	}
	if (cmd == "import") {

		string& fname = *parlist.front();
		cout << "Reading SKETCH Program in File " << fname << endl;


		void* scanner;
		INp::yylex_init(&scanner);
		INp::yyset_in(fopen(fname.c_str(), "r"), scanner);
		int tmp = INp::yyparse(scanner);
		INp::yylex_destroy(scanner);
		cout << "DONE INPUTING" << endl;
		for (list<string*>::iterator it = parlist.begin(); it != parlist.end(); ++it) {
			delete *it;
		}
		if (tmp != 0) return tmp;
		return -1;
	}

	Assert(false, "NO SUCH COMMAND" << cmd);
	return 1;
}

/* Takes the specification (spec) and implementation (sketch) and creates a
* single function asserting their equivalence. The Miter is created for
* expressions 'assert sketch SKETCHES spec' in the input file to back-end.
*/
BooleanDAG* InterpreterEnvironment::prepareMiter(BooleanDAG* spec, BooleanDAG* sketch, int inlineAmnt){


//    for(int i = 0; i<sketch->size();i++)
//    {
//        assert((*sketch)[i]->get_name() != "num_bools_4_0_0");
//    }


    if (params.verbosity > 2) {

		cout << "* before  EVERYTHING: " << spec->get_name() << "::SPEC nodes = " << spec->size() << "\t " << sketch->get_name() << "::SKETCH nodes = " << sketch->size() << endl;
	}

	if (params.verbosity > 2) {
		cout << " INBITS = " << params.NINPUTS << endl;
		cout << " CBITS  = " << INp::NCTRLS << endl;
	}

	{
		Dout(cout << "BEFORE Matching input names" << endl);
		auto specIn = spec->getNodesByType(bool_node::SRC);
		auto sketchIn = sketch->getNodesByType(bool_node::SRC);

		int inints = 0;
		int inbits = 0;


//        for(int i = 0; i<sketch->size();i++)
//        {
//            assert((*sketch)[i]->get_name() != "num_bools_4_0_0");
//        }

		Assert(specIn.size() <= sketchIn.size(), "The number of inputs in the spec and sketch must match");
		for (int i = 0; i<specIn.size(); ++i) {
			SRC_node* sknode = dynamic_cast<SRC_node*>(sketchIn[i]);
			SRC_node* spnode = dynamic_cast<SRC_node*>(specIn[i]);
			Dout(cout << "Matching inputs spec: " << sknode->name << " with sketch: " << spnode->name << endl);
			sketch->rename(sknode->name, spnode->name);
			if (sketchIn[i]->getOtype() == OutType::BOOL) {
				inbits++;
			}
			else {
				inints++;
			}
            if (sknode->isTuple) {
                if (sknode->depth == -1)
                  sknode->depth = params.srcTupleDepth;
            }
		}


//        for(int i = 0; i<sketch->size();i++)
//        {
//            assert((*sketch)[i]->get_name() != "num_bools_4_0_0");
//        }


        if (params.verbosity > 2) {
			cout << " input_ints = " << inints << " \t input_bits = " << inbits << endl;
		}

	}

	{
		Dout(cout << "BEFORE Matching output names" << endl);
		auto specDST = spec->getNodesByType(bool_node::DST);
		auto sketchDST = sketch->getNodesByType(bool_node::DST);
		Assert(specDST.size() == sketchDST.size(), "The number of inputs in the spec and sketch must match");

//        for(int i = 0; i<sketch->size();i++)
//        {
//            assert((*sketch)[i]->get_name() != "num_bools_4_0_0");
//        }

		for (int i = 0; i<sketchDST.size(); ++i) {
			DST_node* spnode = dynamic_cast<DST_node*>(specDST[i]);
			DST_node* sknode = dynamic_cast<DST_node*>(sketchDST[i]);
			sketch->rename(sknode->name, spnode->name);
		}


//        for(int i = 0; i<sketch->size();i++)
//        {
//            assert((*sketch)[i]->get_name() != "num_bools_4_0_0");
//        }
	}



	//spec->repOK();
	//sketch->repOK();


	if (false) {
		CallGraphAnalysis cga;
		cout << "sketch:" << endl;
		cga.process(*sketch, functionMap, floats);
		cout << "spec:" << endl;
		cga.process(*spec, functionMap, floats);
	}

	if (params.olevel >= 3) {
		if(params.verbosity > 3){ cout<<" Inlining amount = "<<inlineAmnt<<endl; }
		{
			if (params.verbosity > 3) { cout << " Inlining functions in the sketch." << endl; }
			try {
                map<string, const BooleanDAG*> constdagmap;
                for(auto it : functionMap) {
                    constdagmap[it.first] = it.second;
                }
				doInline(*sketch, constdagmap, inlineAmnt, replaceMap);
			}catch (BadConcretization& bc) {
				sketch->clear();
				spec->clear();
				throw bc;
			}
			

			/*
			ComplexInliner cse(*sketch, function_map, params.inlineAmnt, params.mergeFunctions );
			cse.process(*sketch);
			*/
		}
		{
			if (params.verbosity > 3) { cout << " Inlining functions in the spec." << endl; }
			try {
                map<string, const BooleanDAG*> constdagmap;
                for(auto it : functionMap) {
                    constdagmap[it.first] = it.second;
                }
				doInline(*spec, constdagmap, inlineAmnt, replaceMap);
			} catch (BadConcretization& bc) {
                assert(false);
				sketch->clear();
				spec->clear();
				delete sketch;
				delete spec;
				throw bc;
			}
			

			/*
			ComplexInliner cse(*spec, function_map,  params.inlineAmnt, params.mergeFunctions  );
			cse.process(*spec);
			*/
		}

	}
	//spec->repOK();
	//sketch->repOK();
	Assert(spec->getNodesByType(bool_node::CTRL).size() == 0, "ERROR: Spec should not have any holes!!!");
  
  if(false){
		/* Eliminates uninterpreted functions */
		DagElimUFUN eufun;
		eufun.process(*spec);


		/* ufunSymmetry optimizes based on the following Assumption: -- In the sketch if you have uninterpreted functions it
		can only call them with the parameters used in the spec */
		if (params.ufunSymmetry) { eufun.stopProducingFuns(); }
		eufun.process(*sketch);

	}

	{
		//Post processing to replace ufun inputs with tuple of src nodes.
       replaceSrcWithTuple(*spec);
       replaceSrcWithTuple(*sketch);
	}
	//At this point spec and sketch may be inconsistent, because some nodes in spec will have nodes in sketch as their children.
	spec->makeMiter(sketch);
	BooleanDAG* result = spec;
	
	if (params.verbosity > 6) { cout << "after Creating Miter: Problem nodes = " << result->size() << endl; }


	result = runOptims(result);
  return result;
}

bool_node* createTupleSrcNode(string tuple_name, string node_name, int depth, vector<bool_node*>& newnodes, bool ufun) {
	if (depth == 0) {
		CONST_node* cnode = CONST_node::create(-1);
		newnodes.push_back(cnode);
		return cnode;
	}

	Tuple* tuple_type = dynamic_cast<Tuple*>(OutType::getTuple(tuple_name));
	int size = tuple_type->actSize;
	TUPLE_CREATE_node* new_node = TUPLE_CREATE_node::create(tuple_type->entries.size());
	new_node->depth = depth;
	new_node->setName(tuple_name);
	
	for (int j = 0; j < size; j++) {
		stringstream str;
		str << node_name << "_" << j;

		OutType* type = tuple_type->entries[j];

		if (type->isTuple) {
			new_node->set_parent(j, createTupleSrcNode(((Tuple*)type)->name, str.str(), depth - 1, newnodes, ufun));
		}
		else if (type->isArr && ((Arr*)type)->atype->isTuple) {
			CONST_node* cnode = CONST_node::create(-1);
			newnodes.push_back(cnode);
			new_node->set_parent(j, cnode);

		}
		else {

			SRC_node* src = SRC_node::create(str.str());

			int nbits = 0;
			if (type == OutType::BOOL || type == OutType::BOOL_ARR) {
				nbits = 1;
			}
			if (type == OutType::INT || type == OutType::INT_ARR) {
				nbits = 2;
			}

			if (nbits > 1) { nbits = PARAMS->NANGELICS; }
			src->set_nbits(nbits);
			if (type == OutType::INT_ARR || type == OutType::BOOL_ARR) {
				int sz = 1 << PARAMS->NINPUTS;
				src->setArr(sz);
			}
			newnodes.push_back(src);

			new_node->set_parent(j, src);
		}
	}

	CONST_node* cnode = CONST_node::create(-1);
	newnodes.push_back(cnode);
	for (int i = size; i < tuple_type->entries.size(); i++) {
		new_node->set_parent(i, cnode);
	}
	new_node->addToParents();
	newnodes.push_back(new_node);

	if (ufun) return new_node;

	
	stringstream str;
	str << node_name << "__";

	SRC_node* src = SRC_node::create(str.str());
	src->set_nbits(1);
	newnodes.push_back(src);

	ARRACC_node* ac = ARRACC_node::create(src, cnode, new_node);
	
	ac->addToParents();
	newnodes.push_back(ac);
	return ac;
}


void InterpreterEnvironment::replaceSrcWithTuple(BooleanDAG& dag) {
	vector<bool_node*> newnodes;
	for (int i = 0; i<dag.size(); ++i) {
		if (dag[i]->type == bool_node::SRC) {
			SRC_node* srcNode = dynamic_cast<SRC_node*>(dag[i]);
			if (srcNode->isTuple) {
				int depth = srcNode->depth;
				if (depth == -1) depth = params.srcTupleDepth;
				bool_node* new_node = createTupleSrcNode(srcNode->tupleName, srcNode->get_name(), depth, newnodes, srcNode->ufun);
				dag.replace(i, new_node);
			}
		}
	}

	dag.addNewNodes(newnodes);
	newnodes.clear();
	dag.removeNullNodes();
}



//void findPureFuns(map<string, BooleanDAG*>& function_map, set<string>& pureFuns) {
//
//	for (auto it = function_map.begin(); it != function_map.end(); ++it) {
//		auto ctrlvec = it->second->getNodesByType(bool_node::CTRL);
//		if (ctrlvec.size() == 0) {
//			pureFuns.insert(it->first);
//			continue;
//		}
//		if (ctrlvec.size() == 1 && ctrlvec[0]->get_name() == "#PC") {
//			pureFuns.insert(it->first);
//		}
//	}
//
//	set<string> other;
//	do{
//		other = pureFuns;
//		for (auto it = pureFuns.begin(); it != pureFuns.end(); ++it) {
//			BooleanDAG* bd = function_map[*it];
//
//			auto ufvec = bd->getNodesByType(bool_node::UFUN);
//			for (auto ufit = ufvec.begin(); ufit != ufvec.end(); ++ufit ) {
//
//				UFUN_node* ufn = dynamic_cast<UFUN_node*>(*ufit);
//				if (ufn == NULL) { continue;  }
//				if (other.count(ufn->get_ufun_name()) == 0) {
//					//calling a non-pure function means you are not pure either.
//					other.erase(*it);
//					break;
//				}
//			}
//		}
//		swap(other, pureFuns);
//	} while (other.size() != pureFuns.size());
//
//}

void InterpreterEnvironment::doInline(
        BooleanDAG& dag, map<string, const BooleanDAG*>& functionMap, int steps, map<string, map<string, string> > replaceMap){
	//OneCallPerCSiteInliner fin;
	// InlineControl* fin = new OneCallPerCSiteInliner(); //new BoundedCountInliner(PARAMS->boundedCount);
	TheBestInliner fin(steps, params.boundmode == CommandLineArgs::CALLSITE);
	/*
	if(PARAMS->boundedCount > 0){
	fin = new BoundedCountInliner(PARAMS->boundedCount);
	}else{
	fin = new OneCallPerCSiteInliner();
	}
	*/


//    for(int i = 0; i<dag.size();i++)
//    {
//        assert(dag[i]->get_name() != "num_bools_4_0_0");
//    }


	set<string> pureFuns;

	findPureFuns(functionMap, pureFuns);

	DagFunctionInliner dfi(
	        dag,
	        functionMap,
	        std::move(replaceMap),
	        floats,
	        &hardcoder,
	        pureFuns,
	        params.randomassign,
	        &fin,
	        params.onlySpRandAssign,
	        params.spRandBias);




	int oldSize = -1;
	bool nofuns = false;
	for (int i = 0; i<steps; ++i) {
		int t = 0;
		int ct = 0;
		do {
			if (params.randomassign && params.onlySpRandAssign) {
				if (ct < 2) {
				dfi.turnOffRandomization();
				ct++;
				} else {
				dfi.turnOnRandomization();
				}
			}
            try {
                dfi.process(dag);
            }
            catch(BadConcretization bc)
            {
                throw bc;
            }
			//
			// dag.repOK();
			set<string>& dones = dfi.getFunsInlined();
			if (params.verbosity> 6) { cout << "inlined " << dfi.nfuns() << " new size =" << dag.size() << endl; }
			//dag.lprint(cout);
			if (params.bndDAG > 0 && dag.size() > params.bndDAG) {
				cout << "WARNING: Preemptively stopping CEGIS because the graph size exceeds the limit: " << params.bndDAG << endl;
				exit(1);
			}
			if (oldSize > 0) {
				if(dag.size() > 400000000 && dag.size() > oldSize * 10){
					i = steps;
					cout << "WARNING: Preemptively stopping inlining because the graph was growing too big too fast" << endl;
					break;
				}
				if((dag.size() > 400000 && dag.size() > oldSize * 2)|| dag.size() > 1000000){
					hardcoder.tryHarder();
				}
			}
			oldSize = dag.size();
			++t;
		} while (dfi.changed());
		if (params.verbosity> 6) { cout << "END OF STEP " << i << endl; }
		// fin.ctt.printCtree(cout, dag);

		fin.clear();
		if (t == 1 && params.verbosity> 6) { cout << "Bailing out" << endl; break; }
	}
	hardcoder.afterInline();
	{
		DagFunctionToAssertion makeAssert(dag, functionMap, floats);
		makeAssert.process(dag);
	}

//    for(int i = 0; i<dag.size();i++)
//    {
//        assert(dag[i]->get_name() != "num_bools_4_0_0");
//    }
	
}


ClauseExchange::ClauseExchange(MiniSATSolver* ms, const string& inf, const string& outf)
	:msat(ms), infile(inf), outfile(outf)
{
	failures = 0;

	msat->getShareable(single, baseline, dble);

	//Wipe the files clean
	{
	FILE* f = fopen(infile.c_str(), "w");	
	fclose(f);
	}
	{
	FILE* f = fopen(outfile.c_str(), "w");	
	fclose(f);
	}	
}

void ClauseExchange::exchange(){
	analyzeLocal();
	int ssize = single.size();
	int dsize = dble.size();	
	if (PARAMS->verbosity > 8) {
		cout << "Before readInfile" << endl;
		printToExchange();
	}
	

	readInfile();

	if (PARAMS->verbosity > 8) {
		cout << "After readInfile" << endl;
		printToExchange();
	}

	if(ssize > 0 || dsize > 0){
		pushOutfile();
	}
}

void ClauseExchange::readInfile(){
	int ssize = single.size();
	int dsize = dble.size();
	int bufsize = ssize + dsize*2 + 3;
	bufsize = bufsize * 3;
	bufsize = max(bufsize, 200);
	vector<int> sbuf(bufsize);
	FILE* f = fopen(outfile.c_str(), "r");
	int rsize = fread(&sbuf[0], sizeof(int), bufsize, f);
	if(rsize < 3){
		fclose(f);
		cout<<"Nothing read"<<endl;
		return;
	}
	ssize = sbuf[0]; dsize=sbuf[1];
	int realsize = ssize + dsize*2 + 3;
	if(rsize != realsize){
		if(rsize > realsize){
			fclose(f);
			cout<<"Corrupted"<<endl;
			return;
		}
		if(rsize != bufsize){
			fclose(f);
			cout<<"Corrupted"<<endl;
			return;
		}
		sbuf.resize(realsize);
		rsize = fread(&sbuf[bufsize], sizeof(int), realsize - bufsize, f);
		fclose(f);
		if(rsize + bufsize != realsize){
			cout<<"Corrupted"<<endl;
			return;
		}
	}else{
		fclose(f);
		sbuf.resize(realsize);
	}
	cout << "Received: ";
	for (int i = 0; i < sbuf.size(); ++i) {
		cout << ", " << sbuf[i];
	}
	cout << endl;
	unsigned chksum = 0;
	for(int i=0; i<sbuf.size()-1; ++i){
		chksum += sbuf[i];
	}
	if(chksum != sbuf[sbuf.size()-1]){
		cout<<"Failed checksum"<<endl;
		return;
	}
	{
		vec<Lit> vl(1);
		for(int i=2; i < 2+ssize; ++i){
			int sin = sbuf[i];
			if(single.count(sin)==0){
				single.insert(sin);
				vl[0] = toLit(sin);
				msat->addHelperClause(vl);
			}
		}
	}
	{
		vec<Lit> vl(2);
		for(int i=2+ssize; i< sbuf.size()-1; i+=2){
			int f = sbuf[i];
			int s = sbuf[i+1];
			pair<int, int> p = make_pair(f, s);
			if(dble.count(p) ==0){
				dble.insert(p);
				vl[0] = toLit(f); vl[1] = toLit(s);
				msat->addHelperClause(vl);
			}
		}
	}
}

void ClauseExchange::pushOutfile(){
	int ssize = single.size();
	int dsize = dble.size();
	unsigned chksum = 0;
	vector<int> sbuf(ssize + dsize*2 + 3);
	chksum += ssize;
	chksum += dsize;
	sbuf[0] = ssize;
	sbuf[1] = dsize;
	int i=2;
	for(set<int>::iterator it = single.begin(); it != single.end(); ++it){
		chksum += *it;
		sbuf[i] = *it; ++i;
	}
	for(set<pair<int, int> >::iterator it = dble.begin(); it != dble.end(); ++it){
		chksum += it->first;
		chksum += it->second;
		sbuf[i] = it->first; ++i;
		sbuf[i] = it->second; ++i;
	}
	sbuf[i] = chksum;
	cout << "Sending: " << endl;
	for (int ii = 0; ii < sbuf.size(); ++ii) {
		cout << ", " << sbuf[ii];
	}
	cout << endl;
	FILE* f = fopen(outfile.c_str(), "w");
	fwrite(&sbuf[0], sizeof(int), i+1, f);
	fclose(f);
}

void ClauseExchange::analyzeLocal(){
	single.clear(); dble.clear();
	msat->getShareable(single, dble, baseline);	
}


void InterpreterEnvironment::share(){
	if(exchanger!=NULL){
		exchanger->exchange();
	}
}



void InterpreterEnvironment::fixes(const string& holename) {
	int pos = spskpairs.size();
	if (holesToHardcode.size() <= pos) {
		holesToHardcode.resize(pos + 1);
	}
	Assert(pos > 0, "CAN'T HAPPEN!");
	holesToHardcode[pos-1].push_back(holename);
}

int InterpreterEnvironment::doallpairs() {
//

//    SolverLanguageParser parser("solver_program.txt");
//    return 0;

    if(params.numericalSolver)
    {
        Assert(spskpairs.size() == 1, string("If using numerical solver then CEGISSolver can only handle 1 harness,") +
        string("due to keeping track of pending constraints introduced by the hardcoder, but the NumericalSolver doesn't incorporate those constraints in the solving process"));
    }

	int howmany = params.ntimes;
	if (howmany < 1 || !params.randomassign) { howmany = 1; }
	SATSolverResult result = SAT_UNDETERMINED;


	// A dummy ctrl for inlining bound
	CTRL_node* inline_ctrl = NULL;
	if (params.randomInlining) {
		inline_ctrl = CTRL_node::create();
		inline_ctrl->name = "inline";
		hardcoder.declareControl(inline_ctrl);
	}

	if (acEnabled()) {
		hardcoder.registerAllControls(functionMap);
		if (exchanger == NULL && howmany > 5) {
			string inf = params.inputFname;
			inf += ".com";
			exchanger = new ClauseExchange(hardcoder.getMiniSat(), inf, inf);
		}
	}

	string errMsg;
	maxRndSize = 0;
	hardcoder.setHarnesses(spskpairs.size());

	for (int trailID = 0; trailID<howmany; ++trailID) {
		if (howmany>1) { cout << "ATTEMPT " << trailID << endl; }
		if (trailID % 5 == 4) {
			share();
			if (params.randdegree == 0) {
				hardcoder.adjust();
			}
		}
		if (params.randdegree == 0) {
			hardcoder.setRanddegree(trailID);
		}

		timerclass roundtimer("Round");
		roundtimer.start();

		// Fix a random value to the inlining bound
		int inlineAmnt = params.inlineAmnt;
		int minInlining = 3;
		if (params.inlineAmnt > minInlining && params.randomInlining) {
			inline_ctrl->special_concretize(params.inlineAmnt - minInlining);
			hardcoder.fixValue(*inline_ctrl, params.inlineAmnt - minInlining, 5);
			inlineAmnt = hardcoder.getValue(inline_ctrl->name) + minInlining;
		}

//        bool do_run_hypersketch = params.hypersketch_file_path != "";
//
//        if(do_run_hypersketch)
//        {
//            cout << "RUNNING SOLVE PROGRAM AT: " << params.hypersketch_file_path << endl;
//            BooleanDagLightUtility::new_way = true; // indicates using InlinedAndConcretizer for concretization, rather than inlining ahead of time.
//            assert(howmany == 1);
//            //TODO: Incorporate: hardcoder.setCurHarness((int)i);
//            assert(spskpairs.size() >= 1);
//            string str = spskpairs[0].file;
//            for(int i = 1;i<spskpairs.size();i++)
//            {
//                assert(str == spskpairs[i].file);
//            }
//            result = run_hypersketch(inlineAmnt, spskpairs[0].file);
//            assert(result == SAT_SATISFIABLE);
//            return 0;
//            break;
//        }
//        else
		for (size_t i = 0; i<spskpairs.size(); ++i) {
			hardcoder.setCurHarness((int)i);
			try {
                bool do_run_hypersketch = params.hypersketch_file_path != "";
                if(do_run_hypersketch)
                {
                    cout << "RUNNING SOLVE PROGRAM AT: " << params.hypersketch_file_path << endl;
                    BooleanDagLightUtility::new_way = true; // indicates using InlinedAndConcretizer for concretization, rather than inlining ahead of time.
                    assert(spskpairs.size() >= 1);
//                    string str = spskpairs[0].file;
//                    for(int i = 1;i<spskpairs.size();i++)
//                    {
//                        assert(str == spskpairs[i].file);
//                    }
                    result = run_hypersketch(inlineAmnt, spskpairs[i]);
                }
                else {

                    BooleanDagLightUtility::new_way = false;
                    ProgramEnvironment *program_env =
                            new ProgramEnvironment(params, floats, hardcoder, functionMap, inlineAmnt, replaceMap);

                    BooleanDAG *bd = nullptr;
                    bool use_prepareMiter = true;
                    if (use_prepareMiter) {
                        bd = prepareMiter(getCopy(spskpairs[i].spec), getCopy(spskpairs[i].sketch), inlineAmnt);
                    }

                    BooleanDagLightUtility *local_harness = nullptr;
                    if (BooleanDagLightUtility::new_way) {
                        bool inline_ahead_of_time = true;
                        if (inline_ahead_of_time) {
                            if (use_prepareMiter) {
                                local_harness = new SketchFunction(bd, program_env);
                            } else {
                                local_harness = new SketchFunction(getCopy(spskpairs[i].sketch), program_env);
                                local_harness->inline_this_dag();
                            }
                        } else {
                            local_harness = new SketchFunction(getCopy(spskpairs[i].sketch), program_env);
                        }
                    } else {
                        if (use_prepareMiter) {
                            local_harness = new SketchFunction(bd, program_env);
                        } else {
                            local_harness = new SketchFunction(getCopy(spskpairs[i].sketch), program_env);
                            local_harness = local_harness->produce_inlined_dag(true);
                        }
                    }

//                local_harness->get_dag()->lprint(cout);

                    result = assertHarness(local_harness, cout, spskpairs[i].file);
                }

                printControls("");

                cout << "Final Controls:" << endl;
                for(auto it : currentControls) {
                    cout << "\t" << it.first <<" "<< it.second << endl;
                }

            }
			catch (BadConcretization& bc) {
				errMsg = bc.msg;
				hardcoder.dismissedPending();
				result = SAT_UNSATISFIABLE;
				break;
			}
			if (result != SAT_SATISFIABLE) {
				break;
			}
			if (hardcoder.isDone()) {
				break;
			}
			if (i < holesToHardcode.size()) {
				auto tohardcode = holesToHardcode[i];
				for (auto holes = tohardcode.begin(); holes != tohardcode.end(); ++holes) {
					Tvalue& tv = finder->getControl(*holes);
					auto val = solver->ctrl_store[*holes];
					hardcoder.settleHole(*holes, val);
					if (tv.isSparse()) {
						for (int idx = 0; idx < tv.size(); ++idx) {
							auto gv = tv.num_ranges[idx];
							if (gv.value == val) {
								finder->addAssertClause(gv.guard);
							}
							else {
								finder->addAssertClause(-gv.guard);
							}
						}
					}
					else {
						if (val == 1) {
							finder->addAssertClause(tv.getId());
						}
						else {
							finder->addAssertClause(-tv.getId());
						}
					}

				}
			}

		}


		roundtimer.stop();
		cout << "**ROUND " << trailID << " : " << hardcoder.getTotsize() << " ";
		roundtimer.print("time");
		cout << "RNDDEG = " << hardcoder.getRanddegree() << endl;
		double comp = log(roundtimer.get_cur_ms()) + hardcoder.getTotsize();
		hardcoder.addScore(comp);
		if (result == SAT_SATISFIABLE) {
			if (params.minvarHole) {
				resetMinimize();
				if (hardcoder.isDone()) {
                    cout << "return 0" << endl;
					return 0;
				}
			}
			else {
                cout << "return 0" << endl;
				return 0;
			}
		}
		else {
			if (finder->lastErrMsg != "") {
				errMsg = finder->lastErrMsg;
			}
			reset();
			if (hardcoder.isDone()) {
				if (hasGoodEnoughSolution) {
					cout << "return 0" << endl;
					return 0;
				}
				else {
					cerr << errMsg << endl;
					cout << "return 1" << endl;
					return 1;
				}
			}
		}
	}
	cout << "return 2" << endl;
	return 2; // undefined.
}


/*
SATSolverResult InterpreterEnvironment::assertDAGNumerical(BooleanDAG* harness->get_dag(), ostream& out) {
    Assert(status==READY, "You can't do this if you are UNSAT");
    ++assertionStep;
	
	IntToFloatRewriteDag rewriter = IntToFloatRewriteDag(*harness->get_dag(), floats);
	BooleanDAG* new_dag = rewriter.rewrite();

    reasSolver->addProblem(new_dag);
       	
    int solveCode = 0;
    try{
        solveCode = reasSolver->solve();
        currentControls = rewriter.extract_result(reasSolver->get_result(), reasSolver->get_ctrls());
        //reasSolver->get_control_map(currentControls);
    }catch(SolverException* ex){
        cout<<"ERROR "<<basename()<<": "<<ex->code<<"  "<<ex->msg<<endl;
        status=UNSAT;
		return SAT_UNSATISFIABLE; // ex->code + 2;
    }catch(BasicError& be){
        reasSolver->get_control_map_as_map_str_str(currentControls);
        cout<<"ERROR: "<<basename()<<endl;
        status=UNSAT;
        return SAT_UNSATISFIABLE;
    }
    if( !solveCode ){
        status=UNSAT;				
        return SAT_UNSATISFIABLE;
    }
    
    return SAT_SATISFIABLE;
}
*/

SATSolverResult InterpreterEnvironment::run_hypersketch(int inlineAmnt, const SpecSketchFile& spskpair)
{
    ProgramEnvironment program_env =
            ProgramEnvironment(params, floats, hardcoder, functionMap, inlineAmnt, replaceMap);

//    SL::SketchFunction *local_harness = nullptr;
//    {
//        // backwards-compatible cast to sketch harness.
//        // todo: add @HyperSketch(".hsk") annotation for harnesses in the frontend.
//        BooleanDagLightUtility::new_way = true;
//
//        BooleanDAG *bd = nullptr;
//        bool use_prepareMiter = false;
//        if (use_prepareMiter) {
//            bd = prepareMiter(getCopy(spskpair.spec), getCopy(spskpair.sketch), inlineAmnt);
//        }
//
//        if (BooleanDagLightUtility::new_way) {
//            bool inline_ahead_of_time = false;
//            if (inline_ahead_of_time) {
//                if (use_prepareMiter) {
//                    local_harness = new SL::SketchFunction(bd, &program_env);
//                } else {
//                    local_harness = new SL::SketchFunction(getCopy(spskpair.sketch), &program_env);
//                    local_harness->inline_this_dag();
//                }
//            } else {
//                local_harness = new SL::SketchFunction(getCopy(spskpair.sketch), &program_env);
//            }
//        } else {
//            if (use_prepareMiter) {
//                local_harness = new SL::SketchFunction(bd, &program_env);
//            } else {
//                local_harness = new SL::SketchFunction(getCopy(spskpair.sketch), &program_env);
//                assert(false);// todo
////                local_harness = local_harness->produce_inlined_dag(true);
//            }
//        }
//    }

    SolverLanguage solver_language = SolverLanguage();

    assert(currentControls.empty());
    currentControls = solver_language.eval(
            spskpair.sketch, params.hypersketch_file_path, spskpair.file,
            program_env.function_map, floats,
            params, hardcoder);

    for(const auto& it: program_env.function_map) {
        delete it.second; // keeps the underlying dags, but deletes the skfunc.
    }
    delete &program_env.function_map; //.clear_assert_num_shared_ptr_is_0(); // at this point all dags are cleared.

    return SAT_SATISFIABLE;
}


SATSolverResult InterpreterEnvironment::assertHarness(BooleanDagLightUtility *harness, ostream &out, const string &file) {

    Assert(status == READY, "You can't do this if you are UNSAT");
    ++assertionStep;

    File* new_file;
    if (!file.empty())
    {
        new_file = new File(harness, file);
    }
    else
    {
        new_file = nullptr;
    }

    solver->addProblem(harness, new_file);

    if (params.superChecks) {
        history.push_back(harness->get_dag()->clone());
    }

    if (params.outputEuclid) {
        ofstream fout("bench.ucl");
        Assert(false, "outputEuclid depreciated, but probably not hard to bring back.")
//        solver->outputEuclid(fout);
    }

    if (params.output2QBF) {
        string fname = basename();
        fname += "_2qbf.cnf";
        ofstream out(fname.c_str());
        cout << " OUTPUTING 2QBF problem to file " << fname << endl;
        solver->setup2QBF(out);
    }

    if (harness->get_dag()->useSymbolic()) {
        DeductiveSolver deductive(harness->get_dag__non_const(), this->floats);
        deductive.symbolicSolve(*this->finder);


        solver->ctrl_store.synths.clear();
        auto end = this->finder->get_sins().end();
        for (auto it = this->finder->get_sins().begin(); it != end; ++it) {
            solver->ctrl_store.synths[it->first] = it->second;
        }
        solver->ctrl_store.finalizeSynthOutputs();
        recordSolution();
        return SAT_SATISFIABLE;
    }


    int solveCode = 0;
    try {

        solveCode = solver->solve().success;
        if (solveCode || !hasGoodEnoughSolution) {
            recordSolution();
        }
    }
    catch (SolverException* ex) {
        cout << "ERROR " << basename() << ": " << ex->code << "  " << ex->msg << endl;
        status = UNSAT;
        return ex->code;
    }
    catch (BasicError& be) {
        if (!hasGoodEnoughSolution) {
            recordSolution();
        }
        cout << "ERROR: " << basename() << endl;
        status = UNSAT;
        return SAT_ABORTED;
    }
    if (!solveCode) {
        status = UNSAT;
        return SAT_UNSATISFIABLE;
    }

    /*
	if (false) {
		statehistory.push_back(solver->find_history);

		for (int i = 0; i<history.size(); ++i) {
			cout << " ~~~ Order = " << i << endl;
			BooleanDAG* bd = hardCodeINode(history[i], solver->ctrlStore, bool_node::CTRL, floats);
			int sz = bd->getNodesByType(bool_node::ASSERT).size();
			cout << " ++ Order = " << i << " size = " << sz << endl;
			if (sz > 0) {
				Strudel st(statehistory[i], &finder->getMng(), floats);
				st.checker(history[i], solver->ctrlStore, bool_node::CTRL);
			}
		}
	}
	*/
    return SAT_SATISFIABLE;
}


SATSolverResult InterpreterEnvironment::assertDAG(BooleanDAG *dag, ostream &out, const string &file) {

    //DEPRECIATED BC IT IS EXPECTED THAT DAG IS WRAPPED IN AT LEAST A BooleanDagLightUtility
    assert(false);

/*
 *
    /// *** STILL IN PROGRESS
    ///  vvvvvvvvvvvvvvvvvvvv
    bool test_solver_language = false;
    if (test_solver_language)
    {
        SolverLanguage solver_language = SolverLanguage();
        AssertDebug(false, "need to pass a ProgramEnvironment to FunctionMap.")
        const SolverLanguagePrimitives::HoleAssignment* ret = solver_language.eval(
                new SketchFunction(dag), file, floats, params, hardcoder, hasGoodEnoughSolution,
                *(new FunctionMap(nullptr))
                );

        cout << "EXITED SolverLanguage" << endl;
        if (ret->get_sat_solver_result() != SAT_SATISFIABLE)
        {
            status = UNSAT;
        }
        if(ret->has_assignment_skval()) {
            hardcoder.get_control_map(currentControls);
            ret->get_control_map(currentControls);
            cout << "recorded_solution" << endl;
            cout << "VALUES ";
            for (auto it = currentControls.begin(); it != currentControls.end(); ++it) {
                cout << it->first << ": " << it->second << ", ";
            }
            cout << endl;
        }
        else
        {
            cout << "No solution" << endl;
        }
        cout << "EXITING assertDAG" << endl;
        return ret->get_sat_solver_result();
    }
    ///  ^^^^^^^^^^^^^^^^^^^
    */

	Assert(status == READY, "You can't do this if you are UNSAT");
	++assertionStep;

	File* new_file;
	if (!file.empty())
	{
	    AssertDebug(false, "Incorporate prog_evn, activate line below.");
//	    new_file = new File(dag, file, floats);
	}
	else
	{
	    new_file = nullptr;
	}

    solver->addProblem(new SketchFunction(dag), new_file);

	//	cout << "InterpreterEnvironment: new problem" << endl;
	//	problem->lprint(cout);

	if (params.superChecks) {
		history.push_back(dag->clone());
	}

	// problem->repOK();



	if (params.outputEuclid) {
		ofstream fout("bench.ucl");
        Assert(false, "outputEuclid, but easily fixable.")
//		solver->outputEuclid(fout);
	}

	if (params.output2QBF) {
		string fname = basename();
		fname += "_2qbf.cnf";
		ofstream out(fname.c_str());
		cout << " OUTPUTING 2QBF problem to file " << fname << endl;
		solver->setup2QBF(out);
	}

	if (dag->useSymbolic()) {		
		DeductiveSolver deductive(dag, this->floats);
		deductive.symbolicSolve(*this->finder);	
		

		solver->ctrl_store.synths.clear();
		auto end = this->finder->get_sins().end();
		for (auto it = this->finder->get_sins().begin(); it != end; ++it) {
			solver->ctrl_store.synths[it->first] = it->second;
		}
		solver->ctrl_store.finalizeSynthOutputs();
		recordSolution();
		return SAT_SATISFIABLE;
	}


	int solveCode = 0;
	try {

		solveCode = solver->solve(numeric_limits<unsigned long long>::max()).success;
		if (solveCode || !hasGoodEnoughSolution) {
			recordSolution();
		}
	}
	catch (SolverException* ex) {
		cout << "ERROR " << basename() << ": " << ex->code << "  " << ex->msg << endl;
		status = UNSAT;
		return ex->code;
	}
	catch (BasicError& be) {
		if (!hasGoodEnoughSolution) {
			recordSolution();
		}
		cout << "ERROR: " << basename() << endl;
		status = UNSAT;
		return SAT_ABORTED;
	}
	if (!solveCode) {
		status = UNSAT;
		return SAT_UNSATISFIABLE;
	}

	/*
	if (false) {
		statehistory.push_back(solver->find_history);

		for (int i = 0; i<history.size(); ++i) {
			cout << " ~~~ Order = " << i << endl;
			BooleanDAG* bd = hardCodeINode(history[i], solver->ctrlStore, bool_node::CTRL, floats);
			int sz = bd->getNodesByType(bool_node::ASSERT).size();
			cout << " ++ Order = " << i << " size = " << sz << endl;
			if (sz > 0) {
				Strudel st(statehistory[i], &finder->getMng(), floats);
				st.checker(history[i], solver->ctrlStore, bool_node::CTRL);
			}
		}
	}
	*/
	return SAT_SATISFIABLE;
}

int InterpreterEnvironment::assertDAG_wrapper(BooleanDAG* dag) {
	ostream& out = std::cout;
	return assertDAG(dag, out, "");
}

int InterpreterEnvironment::assertDAG_wrapper(BooleanDAG* dag, const char* fileName) {
	ofstream out(fileName, ios_base::out);
	return assertDAG(dag, out, "");
}

BooleanDAG* InterpreterEnvironment::runOptims(BooleanDAG* result){		
	if (params.olevel >= 3) {
		DagOptim cse(*result, floats);	
		//cse.alterARRACS();
		cse.process(*result);
	}
	// result->repOK();

	// if(params.verbosity > 3){cout<<"* after OPTIM: Problem nodes = "<<result->size()<<endl;	}
	/*{
	DagOptim op(*result);
	result->replace(5598, op.getCnode(1));
	op.process(*result);
	}*/



	if (false && params.olevel >= 5) {
		BackwardsAnalysis opt;
		cout << "BEFORE ba: " << endl;
		//result->print(cout);
		opt.process(*result);
		cout << "AFTER ba: " << endl;
		// result->print(cout);
	}
	// result->repOK();
	if (params.olevel >= 7) {
		cout << "BEFORE OptimizeCommutAssoc" << result->size() << endl;
		DagOptimizeCommutAssoc opt;
		opt.process(*result);
		cout << "AFTER OptimizeCommutAssoc " << result->size() << endl;
	}
	// result->repOK();
	//result->print(cout) ;

	// cout<<"* after CAoptim: Problem nodes = "<<result->size()<<endl;

	if (params.olevel >= 4) {
		DagOptim cse(*result, floats);	
		if (params.alterARRACS) {
			cout << " alterARRACS" << endl;
			cse.alterARRACS();
		}
		cse.process(*result);
	}
	// result->repOK();	
	if (params.verbosity > 0) { cout << "* Final Problem size: Problem nodes = " << result->size() << endl; }
	if (params.showDAG) {
		result->lprint(cout);
	}
	if (params.outputMRDAG) {
		ofstream of(params.mrdagfile.c_str());
		cout << "Outputing Machine Readable DAG to file " << params.mrdagfile << endl;
		result->mrprint(of);
		of.close();
	}
	if(params.outputSMT){
		ofstream of(params.smtfile.c_str());
		cout<<"Outputing SMT for DAG to file "<<params.smtfile<<endl;
		result->smtlinprint(of, params.NINPUTS);
		of.close();
	}
    if(params.outputExistsSMT){
		ofstream of(params.smtfile.c_str());
		cout<<"Outputing SMT for DAG to file "<<params.smtfile<<endl;
		result->smt_exists_print(of);
		of.close();
		exit(1);
	}
	return result;
}



bool hasFloatInputs(bool_node* node) {
  //vector<bool_node*> parents = node->parents();
	for (auto it = node->p_begin(); it != node->p_end(); ++it) {
    if ((*it) != NULL && (*it)->getOtype() == OutType::FLOAT) return true;
  }
  return false;
}

bool hasFloatChild(bool_node* node) {
  FastSet<bool_node> children = node->children;
  for(child_iter it = children.begin(); it != children.end(); ++it){
    if ((*it)->getOtype() == OutType::FLOAT) return true;
  }
  return false;
}


void print(set<bool_node*> nodes) {
  set<bool_node*>::iterator it;
  for (it = nodes.begin(); it != nodes.end(); it++) {
    cout << (*it)->lprint() << endl;
  }
}
/*
void InterpreterEnvironment::abstractNumericalPart(BooleanDAG& dag) {
  vector<bool_node*> newnodes;
  set<bool_node*> seenNodes;
  DagOptim op(dag, floats);
  BooleanDAG& dagclone = (*dag.clone());
  vector<OutType*> rettypes;
  string fname = "_GEN_NUM_SYNTH";

  vector<bool_node*> funparents;
  vector<bool_node*> tuplecparents;
  vector<TUPLE_R_node*> trnodes;
  
  BooleanDAG* funDag = new BooleanDAG(fname); // store the abstraction in this dag
  
  set<bool_node*> funNodes;
  
  for(int i=0; i<dag.size() ; ++i ) {
    bool_node* node = dag[i];
    if (seenNodes.find(node) == seenNodes.end()) {
      seenNodes.insert(node);
      if (node == NULL) continue;
      int nid = node->id;
      OutType* type = node->getOtype();
      //cout << dagclone[nid]->lprint() << endl;
      
      
      if (type == OutType::INT || type == OutType::BOOL  ) {
        bool hasFlChild = hasFloatChild(node);
        bool hasFlInputs = hasFloatInputs(dagclone[nid]);
        if (hasFlChild) {
          if (hasFlInputs) {
			  CTRL_node* ctrl =  CTRL_node::create(); // TODO: this ctrl should be angelic
			  ctrl->name = "CTRL_" + std::to_string(seenNodes.size());
          
			  int nbits = 0;
			  if (type == OutType::BOOL || type == OutType::BOOL_ARR) {
				nbits = 1;
			  }
			  if (type == OutType::INT || type == OutType::INT_ARR) {
				nbits = 5;
			  }
          
			  ctrl->set_nbits(nbits);
          
			  if(type == OutType::INT_ARR || type == OutType::BOOL_ARR) {
				ctrl->setArr(PARAMS->angelic_arrsz);
			  }
			  newnodes.push_back(ctrl);
			  funparents.push_back(ctrl);
          } else {
			  funparents.push_back(node);
          }
          
        
      
          SRC_node* src =  SRC_node::create("PARAM_" + std::to_string(seenNodes.size()));
          int nbits = 0;
          if (type == OutType::BOOL || type == OutType::BOOL_ARR) {
            nbits = 1;
          }
          if (type == OutType::INT || type == OutType::INT_ARR) {
            nbits = 2;
          }
          
          if (nbits > 1) { nbits = PARAMS->NANGELICS; }
          src->set_nbits(nbits);
          if(type == OutType::INT_ARR || type == OutType::BOOL_ARR) {
            int sz = 1 << PARAMS->NINPUTS;
            src->setArr(sz);
          }
          
          funNodes.insert(src);
          dagclone[nid]->neighbor_replace(src);
        }
        if (hasFlInputs) {
          funNodes.insert(dagclone[nid]);
		  tuplecparents.push_back(dagclone[nid]);
          TUPLE_R_node* tnode = TUPLE_R_node::create();
          tnode->idx = rettypes.size();                    
		  trnodes.push_back(tnode);
          newnodes.push_back(tnode);
          dag.replace(nid, tnode);
          rettypes.push_back(type);
          if (hasFlChild) {
            EQ_node* eq = EQ_node::create();
            eq->mother() = tnode;
            int sz = funparents.size();
            eq->father() = funparents[sz-1];
            eq->addToParents();
            newnodes.push_back(eq);
            ASSERT_node* an = ASSERT_node::create();
            an->mother() = eq;
            an->addToParents();
            newnodes.push_back(an);
            dag.assertions.append(getDllnode(an));
            
          }
        }
      }
      if (type == OutType::FLOAT) {
        funNodes.insert(dagclone[nid]);
        node->dislodge();
        //dag.replace(nid, NULL);
      }
    }
  }


  TUPLE_CREATE_node* funOutput = TUPLE_CREATE_node::create(tuplecparents);
  funOutput->setName(fname);

  UFUN_node* unode = UFUN_node::create(fname, funparents);
  unode->outname = "_p_out_" + fname;
  unode->set_tupleName(fname);
  unode->set_nbits(0);
  unode->ignoreAsserts = true; // This is ok because the code represented by this ufun has no asserts.  
  unode->mother() = op.getCnode(1);

  for (auto it = trnodes.begin(); it != trnodes.end(); ++it) {
	  (*it)->mother() = unode;
	  (*it)->addToParents();
  }



  vector<bool_node*> v(funNodes.begin(), funNodes.end());
  funDag->addNewNodes(v);
  funOutput->addToParents();
  funDag->addNewNode(funOutput);
  funDag->create_outputs(-1, funOutput);
  funDag->registerOutputs();
  OutType::makeTuple(fname, rettypes, -1);
  unode->addToParents();
  newnodes.push_back(unode);
  funDag->cleanup();
  funDag->cleanup_children();
  numericalAbsMap[fname] = funDag;
  funDag->lprint(cout);
  dag.addNewNodes(newnodes);
  op.cleanup(dag);  
  //dag.lprint(cout);
  //funDag->repOK();
  
  finder->setNumericalAbsMap(numericalAbsMap);
  
}


*/


/*
 *

 commit: e2ce24fe204235b26a28bcb9fdad2f9ec2b834f5
 @Nov 11th, 2021

1. Finalized refactoring of inlining and concretization.
2. Handling #PC node as intended when concretizing functions.
3. Added seed to random generator in File for the sampler.
4. Hardcoded progressive partial concretization for boolean_synthesis sketch in unroll_and_concertize_function.
5. Fixed bugs in SkVal and translations. Also added invariant checking.
6. Added is_array in Obj in VarStore, and also added method to check equality between two objs.
7. added default: Assert(false, "missing case"); for all switch blocks that that didn't have a default case.

Ran tests in seq: 14 fail. List of failed tests is at the end of InterpreterEnvironment.cpp.


Failed tests:
echo "LISTED BELOW ARE THE FAILED TESTS (IF ANY)"
LISTED BELOW ARE THE FAILED TESTS (IF ANY)
diff -w cur ref > result; cat result; wc `(cat result | awk '/>/{print $2}' | sed 's/\.output/\.sk/g');echo "cur"`
353a354
> miniTestb358.output
371a373
> miniTestb377.output
378a381
> miniTestb385.output
427a431,432
> miniTestb435.output
> miniTestb436.output
556a562
> miniTestb567_angelic.output
666a673
> miniTestb678.output
830a838
> miniTestb841.output
848a857,859
> miniTestb860.output
> miniTestb861.output
> miniTestb862.output
854a866
> miniTestb869.output
864a877
> miniTestb880.output
892a906
> miniTestBigInts2.output
    32    123    729 miniTestb358.sk
   212    745   4630 miniTestb377.sk
    20     65    409 miniTestb385.sk
    25     78    459 miniTestb435.sk
    25     81    470 miniTestb436.sk
   140    499   2695 miniTestb567_angelic.sk
  2894   9528 146863 miniTestb678.sk
   588   6967  35372 miniTestb841.sk
    64    105    971 miniTestb860.sk
    37     65    603 miniTestb861.sk
    29     59    441 miniTestb862.sk
    75    314   1743 miniTestb869.sk
    35    104    687 miniTestb880.sk
    30     85    460 miniTestBigInts2.sk
   896    896  18024 cur
  5102  19714 214556 total
echo "END OF LIST"
END OF LIST

 */


/*

@Jan 23rd, 2022

Running with 0.02mins timeout
50 tests fail.

LISTED BELOW ARE THE FAILED TESTS (IF ANY)
diff -w cur ref > result; cat result; wc `(cat result | awk '/>/{print $2}' | sed 's/\.output/\.sk/g');echo "cur"`
183a184,186
> miniTestb180.output
> miniTestb181.output
> miniTestb182.output
229a233
> miniTestb228.output
246a251
> miniTestb246.output
257a263,264
> miniTestb258.output
> miniTestb259.output
258a266,267
> miniTestb261.output
> miniTestb262.output
265a275
> miniTestb270.output
306a317
> miniTestb312.output
313a325
> miniTestb320_hole.output
330a343,344
> miniTestb347.output
> miniTestb348.output
339a354
> miniTestb358.output
340a356
> miniTestb360.output
349a366
> miniTestb370.output
353a371
> miniTestb375.output
354a373
> miniTestb377.output
362a382
> miniTestb386.output
364a385
> miniTestb389.output
374a396
> miniTestb400.output
387a410
> miniTestb414.output
398a422
> miniTestb426.output
404a429
> miniTestb433.output
405a431,432
> miniTestb435.output
> miniTestb436.output
457a485
> miniTestb489.output
498a527
> miniTestb531.output
530a560
> miniTestb566_angelic.output
531a562
> miniTestb567_angelic.output
641a673
> miniTestb678.output
668a701
> miniTestb706.output
757a791
> miniTestb795.output
759a794
> miniTestb798.output
802a838
> miniTestb841.output
811a848,849
> miniTestb851.output
> miniTestb852.output
818a857,859
> miniTestb860.output
> miniTestb861.output
> miniTestb862.output
823a865,866
> miniTestb868.output
> miniTestb869.output
829a873
> miniTestb876.output
832a877
> miniTestb880.output
836a882
> miniTestb885.output
845a892
> miniTestb895.output
846a894
> miniTestb897.output
851a900
> miniTestb903.output
856a906
> miniTestBigInts2.output
    22     64    343 miniTestb180.sk
    26     68    369 miniTestb181.sk
    26     75    385 miniTestb182.sk
   128    447   3012 miniTestb228.sk
    36    120    744 miniTestb246.sk
    33     85    624 miniTestb258.sk
    40    114    805 miniTestb259.sk
    24     80    573 miniTestb261.sk
    18     66    403 miniTestb262.sk
    14     37    229 miniTestb270.sk
    28    101    740 miniTestb312.sk
    38    157   1080 miniTestb320_hole.sk
   126    420   2701 miniTestb347.sk
    22     81    675 miniTestb348.sk
    32    123    729 miniTestb358.sk
    19     61    358 miniTestb360.sk
    20     84    634 miniTestb370.sk
    28     71    433 miniTestb375.sk
   212    745   4630 miniTestb377.sk
   718   2390  15669 miniTestb386.sk
    15     48    363 miniTestb389.sk
    88    226   1973 miniTestb400.sk
   185    428   3057 miniTestb414.sk
    21     53    446 miniTestb426.sk
    17     53    313 miniTestb433.sk
    25     78    459 miniTestb435.sk
    25     81    470 miniTestb436.sk
    81    226   1729 miniTestb489.sk
    16     47    320 miniTestb531.sk
   105    329   2075 miniTestb566_angelic.sk
   140    499   2695 miniTestb567_angelic.sk
  2894   9528 146863 miniTestb678.sk
   125    535   3074 miniTestb706.sk
   102    379   2260 miniTestb795.sk
   147    549   2937 miniTestb798.sk
   588   6967  35372 miniTestb841.sk
  1626   5939  45424 miniTestb851.sk
   336   1749   9832 miniTestb852.sk
    64    105    971 miniTestb860.sk
    37     65    603 miniTestb861.sk
    29     59    441 miniTestb862.sk
    46    170    949 miniTestb868.sk
    75    314   1743 miniTestb869.sk
    65    266   1590 miniTestb876.sk
    35    104    687 miniTestb880.sk
    89    332   2237 miniTestb885.sk
   204    527   4831 miniTestb895.sk
    31     84    707 miniTestb897.sk
    12     45    328 miniTestb903.sk
    30     85    460 miniTestBigInts2.sk
   860    860  17291 cur
  9723  36119 327636 total
echo "END OF LIST"
END OF LIST
rm cur

 running with 0.2min timeout
 failing: 34

 LISTED BELOW ARE THE FAILED TESTS (IF ANY)
diff -w cur ref > result; cat result; wc `(cat result | awk '/>/{print $2}' | sed 's/\.output/\.sk/g');echo "cur"`
183a184,186
> miniTestb180.output
> miniTestb181.output
> miniTestb182.output
229a233
> miniTestb228.output
258a263,264
> miniTestb258.output
> miniTestb259.output
259a266,267
> miniTestb261.output
> miniTestb262.output
266a275
> miniTestb270.output
344a354
> miniTestb358.output
345a356
> miniTestb360.output
354a366
> miniTestb370.output
360a373
> miniTestb377.output
371a385
> miniTestb389.output
381a396
> miniTestb400.output
394a410
> miniTestb414.output
412a429
> miniTestb433.output
413a431,432
> miniTestb435.output
> miniTestb436.output
542a562
> miniTestb567_angelic.output
652a673
> miniTestb678.output
769a791
> miniTestb795.output
771a794
> miniTestb798.output
814a838
> miniTestb841.output
823a848
> miniTestb851.output
831a857,859
> miniTestb860.output
> miniTestb861.output
> miniTestb862.output
836a865,866
> miniTestb868.output
> miniTestb869.output
842a873
> miniTestb876.output
845a877
> miniTestb880.output
859a892
> miniTestb895.output
872a906
> miniTestBigInts2.output
    22     64    343 miniTestb180.sk
    26     68    369 miniTestb181.sk
    26     75    385 miniTestb182.sk
   128    447   3012 miniTestb228.sk
    33     85    624 miniTestb258.sk
    40    114    805 miniTestb259.sk
    24     80    573 miniTestb261.sk
    18     66    403 miniTestb262.sk
    14     37    229 miniTestb270.sk
    32    123    729 miniTestb358.sk
    19     61    358 miniTestb360.sk
    20     84    634 miniTestb370.sk
   212    745   4630 miniTestb377.sk
    15     48    363 miniTestb389.sk
    88    226   1973 miniTestb400.sk
   185    428   3057 miniTestb414.sk
    17     53    313 miniTestb433.sk
    25     78    459 miniTestb435.sk
    25     81    470 miniTestb436.sk
   140    499   2695 miniTestb567_angelic.sk
  2894   9528 146863 miniTestb678.sk
   102    379   2260 miniTestb795.sk
   147    549   2937 miniTestb798.sk
   588   6967  35372 miniTestb841.sk
  1626   5939  45424 miniTestb851.sk
    64    105    971 miniTestb860.sk
    37     65    603 miniTestb861.sk
    29     59    441 miniTestb862.sk
    46    170    949 miniTestb868.sk
    75    314   1743 miniTestb869.sk
    65    266   1590 miniTestb876.sk
    35    104    687 miniTestb880.sk
   204    527   4831 miniTestb895.sk
    30     85    460 miniTestBigInts2.sk
   876    876  17624 cur
  7927  29395 285179 total
echo "END OF LIST"
END OF LIST

running with 10 minute timeout
 failing: 10

 runtime: less than 4 hours.

 LISTED BELOW ARE THE FAILED TESTS (IF ANY)
diff -w cur ref > result; cat result; wc `(cat result | awk '/>/{print $2}' | sed 's/\.output/\.sk/g');echo "cur"`
353a354
> miniTestb358.output
371a373
> miniTestb377.output
428a431,432
> miniTestb435.output
> miniTestb436.output
668a673
> miniTestb678.output
832a838
> miniTestb841.output
850a857,859
> miniTestb860.output
> miniTestb861.output
> miniTestb862.output
856a866
> miniTestb869.output
    32    123    729 miniTestb358.sk
   212    745   4630 miniTestb377.sk
    25     78    459 miniTestb435.sk
    25     81    470 miniTestb436.sk
  2894   9528 146863 miniTestb678.sk
   588   6967  35372 miniTestb841.sk
    64    105    971 miniTestb860.sk
    37     65    603 miniTestb861.sk
    29     59    441 miniTestb862.sk
    75    314   1743 miniTestb869.sk
   900    900  18116 cur
  4881  18965 210397 total
echo "END OF LIST"
END OF LIST
rm cur


 */


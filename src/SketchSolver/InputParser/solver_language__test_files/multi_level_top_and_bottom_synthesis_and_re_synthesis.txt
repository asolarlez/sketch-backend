/*

SEE binary_boolean_predicates_dsl.sk

*/

//----HyperSketch----

Solver main()
{
    int trials_mult = 32;
    int rows_mult = 4;

    int small_num_trials = 1*trials_mult;
    int big_num_trials = 4*trials_mult;

    float timeout = float(1)/float(4); // in seconds
    float timeout_mult = float(2); // in seconds

    _left_branch__Wrapper = sketch_main__Wrapper.produce_replace(
        "sketch_main",
        sketch_main.produce_replace(
            "composite_predicate",
            left_branch.deep_clone()
        )
    );
    file = File(file_name, _left_branch__Wrapper);
    local_dags = best_effort_programs(
        _left_branch__Wrapper, file, 6*small_num_trials, 1*rows_mult, timeout, file.size()-1, []);
    timeout = timeout * timeout_mult;
    local_dags = best_effort_programs(
        _left_branch__Wrapper, file, 3*small_num_trials, 2*rows_mult, timeout, file.size()-1, local_dags);
    timeout = timeout * timeout_mult;
    local_dags = best_effort_programs(
        _left_branch__Wrapper, file, 2*small_num_trials, 3*rows_mult, timeout, file.size()-1, local_dags);
    timeout = timeout * timeout_mult;
    local_dags = best_effort_programs(
        _left_branch__Wrapper, file, (3*small_num_trials)/2, 4*rows_mult, timeout, file.size()-1, local_dags);
    timeout = timeout * timeout_mult;
    local_dags = best_effort_programs(
        _left_branch__Wrapper, file, (6*small_num_trials)/5, 5*rows_mult, timeout, file.size()-1, local_dags);
    timeout = timeout * timeout_mult;
    local_dags = best_effort_programs(
        _left_branch__Wrapper, file, small_num_trials, 6*rows_mult, timeout, file.size()-1, local_dags);
    timeout = timeout * timeout_mult;

    frontier_union_intersection = Frontier(4);
    int first_loop_consider_best = 6;
    if(first_loop_consider_best > local_dags.size())
    {
        first_loop_consider_best = local_dags.size();
    }
    int second_loop_consider_best = 64;
    if(second_loop_consider_best > local_dags.size())
    {
        second_loop_consider_best = local_dags.size();
    }
    for(int i = 0;i<first_loop_consider_best;i++)
    {
        print("processing dag i", i, "/", first_loop_consider_best);
        for(int j = i+1;j<second_loop_consider_best;j++)
        {

        print("processing dag j", j, "/", second_loop_consider_best);
            left_score = local_dags[i].first();
            left_dag = local_dags[i].second();
            right_score = local_dags[j].first();
            right_dag = local_dags[j].second();

            union = lambda[left_dag, right_dag](x) {
                if (left_dag.passes(x)) {
                    return true;
                }
                return right_dag.passes(x);
            };

            intersection = lambda[left_dag, right_dag](x) {
                if (left_dag.passes(x)) {
                    return right_dag.passes(x);
                }
                return false;
            };

            num_u = file.count(union);
            num_i = file.count(intersection);
            heuristic = ((4*num_u) + num_i);
            bool was_inserted =
                frontier_union_intersection.insert(
                    [num_u, num_i, num_u + num_i, heuristic, "|", left_score, right_score, "@", i, j], // solution
                    [0-heuristic, 0-num_u, 0-num_i, 0-(num_u + num_i)] // score
                );

            bool do_print = false;
            if(do_print)
            {
                print("new");
                print("combine scores: ", left_score, right_score);

                if(was_inserted) {
                    print("was inserted");
                }
                else {
                    print("was not inserted");
                }

                print("print");
                for(int i = 0;i<frontier_union_intersection.size();i++) {
                    print(frontier_union_intersection[i]);
                }
            }
        }

        print("frontier at dag i", i);
        for(int i = 0;i<frontier_union_intersection.size();i++) {
            print(frontier_union_intersection[i]);
        }
    }

    print("START for(int i = 0;i<frontier_union_intersection.size();i++)");
    print("START print(frontier_union_intersection[i]);");

    for(int i = 0;i<frontier_union_intersection.size();i++)
    {
        print(frontier_union_intersection[i]);
    }

    print("DONE print(frontier_union_intersection[i]);");

    if(true)
    {
        ret_dags = [];
        for(int i = 0;i<frontier_union_intersection.size();i++)
        {
            assert(frontier_union_intersection[0][7] == "@");
            main_dag_id = frontier_union_intersection[0][8];
            dual_dag_id = frontier_union_intersection[0][9];
            best_score = local_dags[main_dag_id].first();
            main_dag = local_dags[main_dag_id].second();

            best_dual_score = local_dags[main_dag_id].first();
            best_dual_dag = local_dags[dual_dag_id].second();

            comp_pred = composite_predicate.produce_replace(
                "right_branch",
                 best_dual_dag["sketch_main"]["composite_predicate"]
            );

            comp_pred = comp_pred.produce_replace(
                "left_branch",
                 main_dag["sketch_main"]["composite_predicate"]
            );

            resynth_cond = sketch_main__Wrapper.produce_replace(
                "sketch_main",
                sketch_main.produce_replace(
                    "composite_predicate",
                    comp_pred
                )
            );

            file.relabel(resynth_cond);
            ret_dags = best_effort_programs(
                resynth_cond, file, small_num_trials, 6*rows_mult, timeout, file.size()-1, ret_dags);

        }

        print("FINAL PRINT");

        for(int i = 0; i<ret_dags.size(); i++) {
            print("count ", ret_dags[i].first(), "/", file.size(), "%",
                ((float(100) * float(ret_dags[i].first())) / float(file.size())));
        }

        print("return", ret_dags[0].second());

        return ret_dags[0].second();
    }
    else
    {
        int num_rows_per_sample = 3*rows_mult;
        int delta_num_rows_per_sample = 1;
        int delta_num_trails = 2;

        /*best_score_and_best_dag =
            main_em_cond_branches_step(
                best_score, main_dag, file, big_num_trials,
                delta_num_trails, num_rows_per_sample, delta_num_rows_per_sample);

        best_score = best_score_and_best_dag.first();
        main_dag = best_score_and_best_dag.second();*/

        //--

        file.relabel(main_dag);
        passing_inputs_file = file.produce_filter(lambda[main_dag](x){
            return main_dag.passes(x);});
        failing_inputs_file = file.produce_filter(lambda[main_dag](x){
            return not(main_dag.passes(x, false));});

        print("passing_inputs_file.size()", passing_inputs_file.size());
        print("failing_inputs_file.size()", failing_inputs_file.size());
        assert((passing_inputs_file.size() + failing_inputs_file.size()) == file.size());

        //--

        _right_branch__Wrapper = sketch_main__Wrapper.produce_replace(
            "sketch_main",
            sketch_main.produce_replace(
                "composite_predicate",
                right_branch.deep_clone()
            )
        );
        failing_inputs_file.relabel(_right_branch__Wrapper);
        local_dags = best_effort_programs(
            _right_branch__Wrapper, failing_inputs_file, small_num_trials, num_rows_per_sample, timeout, failing_inputs_file.size()-1, []);

        best_dual_score = local_dags[0].first();
        best_dual_dag = local_dags[0].second();

        /*best_score_and_best_dag =
            main_em_cond_branches_step(
                best_dual_score, best_dual_dag, failing_inputs_file, big_num_trials,
                delta_num_trails, num_rows_per_sample, delta_num_rows_per_sample);

        best_dual_score = best_score_and_best_dag.first();
        best_dual_dag = best_score_and_best_dag.second();*/

        //--

        comp_pred = composite_predicate.produce_replace(
            "right_branch",
             best_dual_dag["sketch_main"]["composite_predicate"]
        );

        comp_pred = comp_pred.produce_replace(
            "left_branch",
             main_dag["sketch_main"]["composite_predicate"]
        );

        resynth_cond = sketch_main__Wrapper.produce_replace(
            "sketch_main",
            sketch_main.produce_replace(
                "composite_predicate",
                comp_pred
            )
        );

        file.relabel(resynth_cond);
        local_dags = best_effort_programs(
            resynth_cond, file, big_num_trials, num_rows_per_sample, timeout, file.size()-1, []);

        best_score = local_dags[0].first();
        best_dag = local_dags[0].second();
    }

    return best_dag;
}

Solver main_em_cond_branches_step(best_score, current_dag, file, num_trials, delta_num_trails, num_rows_per_sample, delta_num_rows_per_sample)
{
    int local_score = best_score;
    all_dags = [];

    best_dag = current_dag;


    int resynth_attempt = 0;
    int num_em_steps = 10;

    for(int em_step = 0; em_step < num_em_steps; em_step ++)
    {
        int max_num_resynth_attempts = 4;

        {

            comp_pred = composite_predicate.produce_replace(
                "right_branch",
                 current_dag["sketch_main"]["composite_predicate"]["right_branch"]
            );

            comp_pred = comp_pred.produce_replace(
                "left_branch",
                 current_dag["sketch_main"]["composite_predicate"]["left_branch"]
            );

            resynth_cond = sketch_main__Wrapper.produce_replace(
                "sketch_main",
                sketch_main.produce_replace(
                    "composite_predicate",
                    comp_pred
                )
            );

            num_trials = num_trials + delta_num_trails;
            num_rows_per_sample = num_rows_per_sample+delta_num_rows_per_sample;

            file.relabel(resynth_cond);
            local_dags = best_effort_programs(resynth_cond, file, num_trials, num_rows_per_sample, timeout, local_score, []);

            all_dags.append(local_dags);

            {
                if(best_score < local_dags[0].first())
                {
                    print("PREV BEST SCORE: ", best_score);
                    best_score = local_dags[0].first();
                    local_score = local_dags[0].first();
                    current_dag = local_dags[0].second();
                    best_dag = current_dag;
                    print("NEW BEST SCORE: ", best_score);
                    print("NEW FINAL DAG!!!");
                }
                else
                {
                    print("PREV BEST SCORE: ", best_score);
                    print("PROPOSAL SCORE: ", local_dags[0].first());
                    print("NO IMPROVEMENT #0");
                    //current_dag = local_dags[0].second();
                    //local_score = local_dags[0].first();
                    resynth_attempt ++;
                    print("FAILED TO FIND BETTER BY BEST EFFORT SYNTHESIS #ATTEMPT", resynth_attempt);
                    if(resynth_attempt >= max_num_resynth_attempts)
                    {
                        print("TOO MANY ATTEMPTS #ATTEMPTS", resynth_attempt);
                        print("RETURN WHAT YOU HAVE");
                        //best score and final dag.

                        ret = [pair<int, SketchFunction>(best_score, best_dag)];
                        return ret[0];
                    }
                }
            }
        }

        {

            calc_composite_predicate =
                lambda[current_dag](){
                    comp_pred = composite_predicate.produce_replace(
                        "condition",
                        current_dag["sketch_main"]["composite_predicate"]["condition"]
                    );

                    comp_pred = comp_pred.produce_replace(
                        "left_branch",
                         current_dag["sketch_main"]["composite_predicate"]["left_branch"]
                    );

                    return comp_pred;
                    assert(false);
                };

            _resynth_branches = sketch_main__Wrapper.produce_replace(
                "sketch_main",
                sketch_main.produce_replace(
                    "composite_predicate",
                    calc_composite_predicate()
                )
            );

            num_trials = num_trials + delta_num_trails;
            num_rows_per_sample = num_rows_per_sample+delta_num_rows_per_sample;

            resynth_branches = _resynth_branches;
            file.relabel(resynth_branches);
            local_dags = best_effort_programs(resynth_branches, file, num_trials, num_rows_per_sample, timeout, local_score, []);

            all_dags.append(local_dags);

            {
                if(best_score < local_dags[0].first())
                {
                    print("PREV BEST SCORE: ", best_score);
                    best_score = local_dags[0].first();
                    local_score = local_dags[0].first();
                    current_dag = local_dags[0].second();
                    best_dag = current_dag;
                    print("NEW BEST SCORE: ", best_score);
                    print("NEW FINAL DAG!!!");
                }
                else
                {
                    print("PREV BEST SCORE: ", best_score);
                    print("PROPOSAL SCORE: ", local_dags[0].first());
                    print("NO IMPROVEMENT #0");
                    //current_dag = local_dags[0].second();
                    //local_score = local_dags[0].first();
                    resynth_attempt ++;
                    print("FAILED TO FIND BETTER BY BEST EFFORT SYNTHESIS #ATTEMPT", resynth_attempt);
                    if(resynth_attempt >= max_num_resynth_attempts)
                    {
                        print("TOO MANY ATTEMPTS #ATTEMPTS", resynth_attempt);
                        print("RETURN WHAT YOU HAVE");
                        //best score and final dag.

                        ret = [pair<int, SketchFunction>(best_score, best_dag)];
                        return ret[0];
                    }
                }
            }
        }

        {
            calc_composite_predicate =
                lambda[current_dag](){
                    comp_pred = composite_predicate.produce_replace(
                        "condition",
                        current_dag["sketch_main"]["composite_predicate"]["condition"]
                    );

                    comp_pred = comp_pred.produce_replace(
                        "right_branch",
                         current_dag["sketch_main"]["composite_predicate"]["right_branch"]
                    );

                    return comp_pred;
                    assert(false);
                };


            _resynth_branches = sketch_main__Wrapper.produce_replace(
                "sketch_main",
                sketch_main.produce_replace(
                    "composite_predicate",
                    calc_composite_predicate()
                )
            );

            num_trials = num_trials + delta_num_trails;
            num_rows_per_sample = num_rows_per_sample+delta_num_rows_per_sample;

            resynth_branches = _resynth_branches;
            file.relabel(resynth_branches);
            local_dags = best_effort_programs(resynth_branches, file, num_trials, num_rows_per_sample, timeout, local_score, []);

            all_dags.append(local_dags);

            {
                if(best_score < local_dags[0].first())
                {
                    print("PREV BEST SCORE: ", best_score);
                    best_score = local_dags[0].first();
                    local_score = local_dags[0].first();
                    current_dag = local_dags[0].second();
                    best_dag = current_dag;
                    print("NEW BEST SCORE: ", best_score);
                    print("NEW FINAL DAG!!!");
                }
                else
                {
                    print("PREV BEST SCORE: ", best_score);
                    print("PROPOSAL SCORE: ", local_dags[0].first());
                    print("NO IMPROVEMENT #0");
                    //current_dag = local_dags[0].second();
                    //local_score = local_dags[0].first();
                    resynth_attempt ++;
                    print("FAILED TO FIND BETTER BY BEST EFFORT SYNTHESIS #ATTEMPT", resynth_attempt);
                    if(resynth_attempt >= max_num_resynth_attempts)
                    {
                        print("TOO MANY ATTEMPTS #ATTEMPTS", resynth_attempt);
                        print("RETURN WHAT YOU HAVE");
                        //best score and final dag.

                        ret = [pair<int, SketchFunction>(best_score, best_dag)];
                        return ret[0];
                    }
                }
            }
        }
    }

    ret = [pair<int, SketchFunction>(best_score, best_dag)];
    return ret[0];

}

Solver best_effort_programs(_harness, file, num_trials, num_rows, float timeout_per_trial, break_early_threshold, old_ret_dags) {

    timestamp();

    print("|.hsk ENTERING best_effort_programs num_trials", num_trials, "num_rows_per_sample", num_rows);

    harness = _harness.deep_clone();

	Solution best_solution;
	int best_score = 0;

    File subset_file;
    Solution solution;
    SketchFunction program;
    int score;

    ret_dags = [];
    for(int trial_id = 0; trial_id<num_trials; trial_id++)
	{
		subset_file = file.produce_subset_file(num_rows); //sample subset of the rows
		solution = SATSolver(harness.deep_clone(), subset_file, timeout_per_trial); // invoke the Sketch Solver on the harness
		subset_file.clear();

		//--{
		    SketchFunction program = harness.produce_executable(solution); // create a program that uses the solution to fill in the holes of the harness.
            int score = program.vectorized_count_passing_inputs(file); // count how many input-output examples are solved with this solution
		//--}
        ret_dags.append(pair<int, SketchFunction>(score, program));
        old_ret_dags.append(pair<int, SketchFunction>(score, program));
		print(
		    "trial", trial_id+1, "/", num_trials,
		    "score", score, "/", file.size(), "%", ((float(100) * float(score)) / float(file.size())),
            "dag.size", program.size());
		if(score > best_score) // update the best_solution
		{
			best_solution = solution;
			best_score = score;
			if(best_score > break_early_threshold)
			{
			    trial_id = num_trials; //break
			}
		}
	}

	ret_dags.sort();
	ret_dags.reverse();
	old_ret_dags.sort();
	old_ret_dags.reverse();

	print("sorted dag scores:");
	int sum_scores = 0;

	for(int i = 0; i<ret_dags.size(); i++)
	{
	    print(
	        "count ", ret_dags[i].first(), "/", file.size(), "%",
	        ((float(100) * float(ret_dags[i].first())) / float(file.size())));
        sum_scores = sum_scores + ret_dags[i].first();
	}
	print("Done sorted solution scores");

	print("best_score = ", best_score);
	print("average_score = ", float(sum_scores)/float(ret_dags.size()));

    return old_ret_dags;
}


pragma options "--bnd-arr-size 3";

bit cbin___meta(bit x0, bit x1)
{
    return {|!(x0 || x1) | x0 ^ x1|};
}

generator bit bin(int n, bit[n] bits)
{
    int id_1 = ??(2);
    assert(id_1 < 3);
    int _id_2 = ??(1);
    int id_2 = _id_2;
    if (id_1 == 0) {
        id_2 = id_2 + 1;
    } else if(id_1 == 1) {
        if(id_2 == 1) {
            id_2 = 2;
        }
    }
    return cbin(bits[id_1], bits[id_2]);
}

generator bit op(int n, bit[n] bits)
{
    return {|bits[??(2)] | bin(n, bits) | 0 | 1 |};
}

generator bit predicate(int n, bit[n] bits) {
    /*return bin(n, bits);
    return bin(bin(n, bits), bin(n, bits));
    return bin(bin(bin(n, bits), bin(n, bits)), bin(n, bits));
    return bin(bin(n, bits), bin(bin(n, bits), bin(n, bits)));
    return bin(bin(bin(n, bits), bin(n, bits)), bin(bin(n, bits), bin(n, bits)));
    */

    return {| op(n, bits) | cbin(op(n, bits), op(n, bits)) | cbin(cbin(op(n, bits), op(n, bits)), op(n, bits)) | cbin(cbin(op(n, bits), op(n, bits)), cbin(op(n, bits), op(n, bits))) | cbin(op(n, bits), cbin(cbin(op(n, bits), op(n, bits)), cbin(op(n, bits), op(n, bits)))) | cbin(cbin(op(n, bits), op(n, bits)), cbin(cbin(op(n, bits), op(n, bits)), cbin(op(n, bits), op(n, bits)))) |};

    /*
    bin(bin(
            bin(bin(n, bits),
                bin(n, bits)),
            bin(bin(n, bits),
                bin(n, bits))),
        bin(
            bin(
                bin(n, bits),
                bin(n, bits)),
            bin(
                bin(n, bits),
                bin(n, bits)
            )
        )
    )

    return
        bin(
            bin(bin(bin(bin(n, bits), bin(n, bits)), bin(bin(n, bits), bin(n, bits))), bin(bin(bin(n, bits), bin(n, bits)), bin(bin(n, bits), bin(n, bits))))
            , 
            bin(bin(bin(bin(n, bits), bin(n, bits)), bin(bin(n, bits), bin(n, bits))), bin(bin(bin(n, bits), bin(n, bits)), bin(bin(n, bits), bin(n, bits))))
        );
    return bin(bin(bin(bin(n, bits), bin(n, bits)), bin(n, bits)), bin(bin(n, bits), bin(n, bits)));
    return bin(bin(bin(n, bits), bin(bin(n, bits), bin(n, bits))), bin(bin(n, bits), bin(n, bits)));
    bit inter = bin(bin(n, bits), bin(n, bits));
    return bin(bin(inter, bin(n, bits)), bin(inter, bits(??[2])));

    int id_1 = ??(2);
    assert(id_1 < 3);
    int _id_2 = ??(1);
    int id_2 = _id_2;
    if (_id_1 == 0) {
        id_2 = id_2 + 1;
    }
    else if(_id_1 == 1)
    {
        if(id_2 == 1)
        {
             id_2 = 2;
        }
    }
    return bin(bits[id_1], bits[id_2]);

    //--

    int one_val = bin(n, bits);
    return bin(one_val, one_val);*/
}

bit program(int n, bit[n] bits){
    return predicate(n, bits);
}


@FromFile("/Users/klimentserafimov/CLionProjects/sketch-backend/src/SketchSolver/InputParser/solver_language__test_files/inputs.txt")
harness void main_sk(int n, bit[n] bits, bit out) {
    assert(program(n, bits) == out);
}
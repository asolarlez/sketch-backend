/*

int program_lvl0(int x)
{
    return program_generator(x);
}

bit top_condition(int x)
{
    return predicate_generator(x);
}

int composite_predicate_left(int x)
{
    return composite_predicate(x);
}

int composite_predicate_right(int x)
{
    return composite_predicate(x);
}

int composite_predicate(int x)
{
    if(??) {
        if(condition(x)) {
            return composite_predicate_left(x);
        }
        else {
            return composite_predicate_right(x);
        }
    }
    else {
        return program_lvl0(x);
    }
}

int dummy_program(int x) {return 1;}

@FromFile("/Users/klimentserafimov/CLionProjects/sketch-backend/src/SketchSolver/InputParser/solver_language__test_files/zig_zag.data")
harness int eval_program_main(int x, int out)
{
    return dummy_program(x);
}

@FromFile("/Users/klimentserafimov/CLionProjects/sketch-backend/src/SketchSolver/InputParser/solver_language__test_files/zig_zag.data")
harness void sketch_main(int x, int out)
{
    assert(composite_predicate(x) == out);
}

*/

/*

//-------------------------------------------
//------------RECURSIVE TREE----------------

//todo

//-------------------------END RECURSIVE TREE -------------------------
//---------------------------------------------------------------------

*/

/*

//--concrete sketch for predicates over bitvectors--

//Space of predicates

InputType  = int num_bits, bit[num_bits] bits;
OutputType = bit;

generator OutputType

generator bit base_program_generator(int num_bits, bit[num_bits] bits, int depth)
{

    int arity = {|0|1|2|};

    if(arity == 2) {
        bit left_bit = base_program_generator(num_bits, bits, depth-1);
        bit right_bit = base_program_generator(num_bits, bits, depth-1);
        return {| (left_bit && right_bit) | (left_bit || right_bit) |};
    }
    else if(arity == 1) {
        bit operand = base_program_generator(num_bits, bits, depth-1);
        return !operand;
    }
    else{
        assert(arity == 0);
        return bits[??];
    }

}

bit base_program(int num_bits, bit[num_bits] bits) {
    int max_depth = 2; //hyperparameter
    return base_program_generator(num_bits, bits, max_depth);
}

bit predicate(int x) {
    int max_depth = 2; //hyperparameter
    return base_program_generator(num_bits, bits, max_depth);
}

*/

/*

//--abstract-sketch--

InputType = //USER DEFINED;
OutputType = //USER DEFINED;

OutputType base_program(InputType x) {
    //USER DEFINED
}

bit predicate(InputType x) {
    //USER DEFINED
}

bit condition(InputType x);

OutputType if_true_branch(InputType x);

OutputType if_false_branch(InputType x);

OutputType composite_program(InputType x) {
    if(condition(x)) {
        return if_true_branch(x);
    }
    else {
        return if_false_branch(x);
    }
}

int program(int x);

harness void sketch_harness(InputType x, OutputType out) {
    assert(program(x) == out);
}

//----HyperSketch----

HyperSketch simple_hypersketch(file_name){
    harness = sketch_harness.clone();
    harness.replace('program', base_program.clone());
    lvl0_programs = best_effort(harness, file_name);
    //base_solution has type vector<pair<int, Sketch> >

    lvl1_programs = [];
    for(int i = 0; i<lvl0_programs.size();i++) {
        for(int j = i+1;j<lvl0_programs.size();j++){

            program_i = lvl0_programs[i].second;
            program_j = lvl0_programs[j].second;

            lvl1_program = composite_program.clone();
            lvl1_program.replace('condition', predicate.clone());
            lvl1_program.replace('if_true_branch', program_i);
            lvl1_program.replace('if_true_branch', program_j);

            lvl1_programs += best_effort(lvl1_program, file_name);
        }
    }

    return max(lvl1_programs+lvl0_programs).second;
}

HyperSketch best_effort(sketch, file_name){

    num_trials = 10; //hyperparameter
    num_rows_per_trial = 6; //hyperparameter

    file = File(file_name);

    solutions = [];
    for(int i = 0; i<num_trials; i++) {
        subfile = file.sample(num_rows_per_trial);
        solution = SATSolver(sketch, subfile);
        executable = sketch.produce_executable(solution)
        score = executable.count_num_passing_inputs(file);
        solutions.append((score, executable));
    }

    return solutions;
}

HyperSketch

*/

hypersketch concatenate(arr1, arr2)
{
    n = arr2.size();
    for(i = 0;i<n;i++)
    {
        arr1.append(arr2.get(i));
    }
}

hypersketch best_effort_programs(harness1, file, num_trials, num_rows_per_sample)
{
    solutions = best_effort_solutions(harness1, file, num_trials, num_rows_per_sample);
    programs = [];
    for(int i = 0;i<solutions.size();i++)
    {
        programs.append(pair<int, SketchFunction>(solutions.get(i).first(), harness1.produce_executable(solutions.get(i).second())));
    }
    return programs;
}

hypersketch best_effort_synthesized_program(harness2, file, num_trials, num_rows_per_sample)
{
    return harness2.produce_executable(
        best_effort_synthesis(harness2, file, num_trials, num_rows_per_sample));
}

hypersketch main()
{

    //return top_down_and_bottom_up_synthesis_sketch_main(true); //with printf
    return top_down_and_bottom_up_synthesis_sketch_main(false); //NOT with printf
    //return recursive_function_stun();
    //return recursive_function_stun_for_benchmarking();


    //return recursive_function_stun_reconstructing_inlined_non_concretized_function_with_replaced_ports();
    //return stun_main();
    //return left_and_right_and_cond_synthesis_sketch_main();
}

hypersketch synthesize_composite_programs_from_parts(left_programs, right_programs, select_best, file_name, num_trials, num_rows_per_sample)
{
    seed_main_lvl1 = [];

    assert(left_programs.size() >= select_best, "FAILED: left_programs.size() <= select_best");
    assert(right_programs.size() >= select_best, "FAILED: right_programs.size() <= select_best");

    for(int i = 0;i<select_best;i++) {
        for(int j = 0;j<select_best;j++) {
            print("LEFT", i+1, "/", select_best, "RIGHT", j+1, "/", select_best);

            //composite_predicate.replace("condition", condition);
            //composite_predicate.replace("if_true_branch", if_true_branch);
            //composite_predicate.replace("if_false_branch", if_false_branch);

            //assert(composite_predicate.num_holes() == 3, "cp has", composite_predicate.num_holes());

            predicate_lvl1 = composite_predicate.produce_replace("condition", predicate.unit_clone());
            print("predicate_lvl1.num_holes()", predicate_lvl1.num_holes());
            int prev_num_holes = predicate_lvl1.num_holes();

            tmp = program_lvl0.produce_executable(left_programs.get(i).second()["sketch_main"]["dummy_program"].get_solution());
            print("tmp.num_holes()", tmp.num_holes());
            int new_num_holes = tmp.num_holes();

            predicate_lvl1.replace("if_true_branch", tmp);
            print("predicate_lvl1.num_holes()", predicate_lvl1.num_holes());
            assert((prev_num_holes + new_num_holes) >= predicate_lvl1.num_holes(), prev_num_holes, "+", new_num_holes, "<", predicate_lvl1.num_holes());

            tmp = program_lvl0.produce_executable(right_programs.get(j).second()["sketch_main"]["dummy_program"].get_solution());
            print("tmp.num_holes()", tmp.num_holes());

            predicate_lvl1.replace("if_false_branch", tmp);
            print("predicate_lvl1.num_holes()", predicate_lvl1.num_holes());

            sketch_main_lvl1_sub = sketch_main.produce_replace("dummy_program", predicate_lvl1);
            print("sketch_main_lvl1_sub.num_holes()", sketch_main_lvl1_sub.num_holes());


            sketch_main_lvl1 = sketch_main__Wrapper.produce_replace("sketch_main", sketch_main_lvl1_sub);
            print("sketch_main_lvl1.num_holes()", sketch_main_lvl1.num_holes());

            File file = File(file_name, sketch_main_lvl1);
            local_num_trials = num_trials * (select_best-i) * (select_best-j);
            local_sketch_main_lvl1_programs = best_effort_programs(sketch_main_lvl1, file, local_num_trials, num_rows_per_sample);

            tmp = [];

            for(int k = 0; k < local_sketch_main_lvl1_programs.size();k++)
            {
                tmp.append(
                    pair<pair<int, SketchFunction>, pair<pair<int, SketchFunction>, pair<int, SketchFunction> > >(
                        local_sketch_main_lvl1_programs.get(k),
                        pair<pair<int, SketchFunction>, pair<int, SketchFunction> >(
                            left_programs.get(i),
                            right_programs.get(j))));
            }

            local_sketch_main_lvl1_programs = tmp;

            concatenate(seed_main_lvl1, local_sketch_main_lvl1_programs);
        }
    }

    seed_main_lvl1.sort();
    seed_main_lvl1.reverse();

    expected_size_of_seed_main_lvl1 = 0;
    for(int i = 0;i<select_best;i++)
    {
        for(int j = 0;j<select_best;j++)
        {
            expected_size_of_seed_main_lvl1 = expected_size_of_seed_main_lvl1 + num_trials*(select_best-i)*(select_best-j);
        }
    }

    assert(seed_main_lvl1.size() == expected_size_of_seed_main_lvl1, "FAILED: seed_main_lvl1.size() != expected_size_of_seed_main_lvl1");

    return seed_main_lvl1;
}

hypersketch top_down_and_bottom_up_synthesis_sketch_main(with_printf)
{
    //for now these are passed as parameters from the sketch.
    //the sketch follows a constraint that the file_names should be the same

    big_num_trials = 10;
    num_rows_per_sample = 3;
    select_best = 2;
    assert(big_num_trials >= select_best);
    small_num_trials = 1;

    sketch_main_lvl0_sub = sketch_main.produce_replace("dummy_program", program_lvl0.unit_clone());
    sketch_main_lvl0 = sketch_main__Wrapper.produce_replace("sketch_main", sketch_main_lvl0_sub);

    File file = File(file_name, sketch_main_lvl0);
    left_lvl0_programs = best_effort_programs(sketch_main_lvl0, file, big_num_trials, num_rows_per_sample);
    print("DONE left_lvl0_programs");
    right_lvl0_programs = best_effort_programs(sketch_main_lvl0, file, big_num_trials, num_rows_per_sample);
    print("DONE right_lvl0_programs");

    assert(left_lvl0_programs.size() >= select_best);
    assert(right_lvl0_programs.size() >= select_best);

    seed_main_lvl1 = synthesize_composite_programs_from_parts(left_lvl0_programs, right_lvl0_programs, select_best, file_name, small_num_trials, num_rows_per_sample);

    all_programs = [];
    concatenate(all_programs, seed_main_lvl1);

    improved_main_lvl1 = [];

    int prev_best = 0-1;
    int new_best = seed_main_lvl1.get(0).first().first();

    assert(big_num_trials >= select_best, "fails:", big_num_trials, "!>=", select_best);

    {
        all_programs.sort();
        all_programs.reverse();

        assert(seed_main_lvl1.size() >= 1);
        assert(all_programs.size() >= 1);
        assert(all_programs.size() >= seed_main_lvl1.size());
        assert(all_programs.get(0).first().first() == seed_main_lvl1.get(0).first().first());

    	for(int i = 0; i<all_programs.size(); i++)
    	{
    	    element = all_programs.get(i);
    	    score = element.first().first();
    	    n = file.size();
    	    print("count ", score, "/", n, "= (", ((float(100) * float(score)) / float(n)), "%)");
    	}
    	print("Done sorted all_programs scores");
    	print("best_from_all_programs = ", all_programs.get(0).first().first());
    }

    int iter_id = 0;

    while((new_best > prev_best))
    {
        num_rows_per_sample++;
        print("NEW_ITERATION", iter_id);
        print("prev_best", prev_best, "new_best", new_best);

        prev_best = new_best;
        new_best = 0;

        for(int i = 0; i<seed_main_lvl1.size();i++)
        {
            improved_main_lvl1.append(seed_main_lvl1.get(i));
        }

        if(seed_main_lvl1.size() < select_best)
        {
            select_best = seed_main_lvl1.size();
        }

        outer_loop_select_best = select_best*select_best;

        if(outer_loop_select_best > seed_main_lvl1.size())
        {
            outer_loop_select_best = seed_main_lvl1.size();
        }

        assert(seed_main_lvl1.size() >= outer_loop_select_best, "FAILED: seed_main_lvl1.size() >= select_best");


        for(int i = 0;i<outer_loop_select_best;i++)
        {
            print("start i =", i+1, "/", outer_loop_select_best);
            print("prev_score: ", seed_main_lvl1.get(i).first().first());
            local_program = seed_main_lvl1.get(i).first().second();
            //take condition
            condition_lvl1_sub_sub = predicate.produce_executable(local_program["sketch_main"]["dummy_program"]["condition"].get_solution());
            condition_lvl1_sub = eval_program_main.produce_replace("dummy_program", condition_lvl1_sub_sub).produce_executable();
            condition_lvl1 = eval_program_main__Wrapper.produce_replace("eval_program_main", condition_lvl1_sub);

            File file = File(file_name, condition_lvl1_sub);
            //split file based on condition
            if_true_file = file.produce_filter(lambda[condition_lvl1_sub](x){
                return condition_lvl1_sub(x);});
            if_false_file = file.produce_filter(lambda[condition_lvl1_sub](x){
                return not(condition_lvl1_sub(x));});

            print("if_true_file.size()", if_true_file.size());
            print("if_false_file.size()", if_false_file.size());

            bool entered = false;
            if(if_true_file.size() >= num_rows_per_sample) {
                if(if_false_file.size() >= num_rows_per_sample) {
                    entered = true;
                    print("ENTER i", i);
                    assert(if_true_file.size() >= num_rows_per_sample, "FAILED: if_true_file.size() >= num_rows_per_sample");
                    assert(if_false_file.size() >= num_rows_per_sample, "FAILED: if_false_file.size() >= num_rows_per_sample");
                    assert((if_true_file.size()+if_false_file.size()) == file.size(), "FAILED: if_true_file.size()+if_false_file.size() == file.size()");

                    //resynthesize lvl0 left and right predicates.

                    local_num_trials = small_num_trials*(outer_loop_select_best - i);

                    left_tmp = sketch_main.produce_replace("dummy_program", program_lvl0.unit_clone());
                    left_sketch_main_lvl0 = sketch_main__Wrapper.produce_replace("sketch_main", left_tmp);
                    if_true_file.relabel(left_sketch_main_lvl0);
                    left_sketch_main_lvl0_programs =
                        best_effort_programs(left_sketch_main_lvl0, if_true_file, local_num_trials, num_rows_per_sample);
                    print("DONE (i = ", i, ") left_sketch_main_lvl0_programs");
                    left_sketch_main_lvl0_programs.append(seed_main_lvl1.get(i).second().first());
                    left_sketch_main_lvl0_programs.sort();
                    left_sketch_main_lvl0_programs.reverse();

                    right_tmp = sketch_main.produce_replace("dummy_program", program_lvl0.unit_clone());
                    right_sketch_main_lvl0 = sketch_main__Wrapper.produce_replace("sketch_main", right_tmp);
                    if_false_file.relabel(right_sketch_main_lvl0);
                    right_sketch_main_lvl0_programs = best_effort_programs(right_sketch_main_lvl0, if_false_file, local_num_trials, num_rows_per_sample);
                    print("DONE (i = ", i, ") right_sketch_main_lvl0_programs");
                    right_sketch_main_lvl0_programs.append(seed_main_lvl1.get(i).second().second());
                    right_sketch_main_lvl0_programs.sort();
                    right_sketch_main_lvl0_programs.reverse();

                    //combine with condition

                    new_best_predicate_lvl1 = composite_predicate.produce_replace("condition", condition_lvl1_sub_sub);
                    new_best_predicate_lvl1.replace("if_true_branch",
                        program_lvl0.produce_executable(left_sketch_main_lvl0_programs.get(0).second()["sketch_main"]["dummy_program"].get_solution()));
                    new_best_predicate_lvl1.replace("if_false_branch",
                        program_lvl0.produce_executable(right_sketch_main_lvl0_programs.get(0).second()["sketch_main"]["dummy_program"].get_solution()));
                    if(with_printf) {
                        new_best_predicate_lvl1.replace("printf",
                            printf.produce_executable(left_sketch_main_lvl0_programs.get(0).second()["sketch_main"]["dummy_program"]["printf"].get_solution()));
                    }
                    new_best_sketch_main_lvl1_sub = sketch_main.produce_replace("dummy_program", new_best_predicate_lvl1);
                    new_best_sketch_main_lvl1 = sketch_main__Wrapper.produce_replace("sketch_main", new_best_sketch_main_lvl1_sub);

                    solution = new_best_sketch_main_lvl1.get_solution();

                    file = File(file_name, new_best_sketch_main_lvl1);
                    dag_for_score = new_best_sketch_main_lvl1.produce_executable();
                    int score = dag_for_score.vectorized_count_passing_inputs(file);

                    print("new_score:", score);

                    improved_main_lvl1.append(
                        pair<pair<int, SketchFunction>, pair<pair<int, SketchFunction>, pair<int, SketchFunction> > >(
                            pair<int, SketchFunction>(score, new_best_sketch_main_lvl1),
                            pair<pair<int, SketchFunction>, pair<int, SketchFunction> >(
                                left_sketch_main_lvl0_programs.get(0),
                                right_sketch_main_lvl0_programs.get(0))));


                    //commented out in ordeer to test the existence of solutions in the very previous statement.
                    if(true){
                        local_num_trials = small_num_trials;
                        new_synthesized_lvl1 =
                            synthesize_composite_programs_from_parts(
                                left_sketch_main_lvl0_programs, right_sketch_main_lvl0_programs,
                                select_best, file_name, local_num_trials, num_rows_per_sample);

                        print("DONE (i = ", i, ") new_synthesized_lvl1");

                        print("synthesized_best_score: ", new_synthesized_lvl1.get(0).first().first());

                        concatenate(improved_main_lvl1, new_synthesized_lvl1);
                    }
                }
            }
            if(not(entered))
            {
                if(outer_loop_select_best < seed_main_lvl1.size())
                {
                    outer_loop_select_best = outer_loop_select_best+1;
                }
            }
            print("DONE i =", i, "FINAL");
        }

        improved_main_lvl1.sort();
        improved_main_lvl1.reverse();

        print("SORTED");

        new_best = improved_main_lvl1.get(0).first().first();
        print("new_best:", new_best);
        seed_main_lvl1 = improved_main_lvl1;
        improved_main_lvl1 = [];
        concatenate(all_programs, seed_main_lvl1);

        all_programs.sort();
        all_programs.reverse();

        for(int i = 0; i<all_programs.size(); i++)
        {
            element = all_programs.get(i);
            score = element.first().first();
            n = file.size();
            print("count ", score, "/", n, "= (", ((float(100) * float(score)) / float(n)), "%)");
        }
        print("Done sorted all_programs scores");
        print("best_from_all_programs = ", all_programs[0].first().first());

        print("UPDATED seed_main_lvl1");

        iter_id++;
    }


    assert(new_best == prev_best, "new_best != prev_best.");

    all_programs.sort();
    all_programs.reverse();

    assert(seed_main_lvl1.size() >= 1, "#1");
    assert(all_programs.size() >= 1, "#2");
    assert(all_programs.size() >= seed_main_lvl1.size(), "#3");
    assert(all_programs.get(0).first().first() == seed_main_lvl1.get(0).first().first(), "#4");

	for(int i = 0; i<all_programs.size(); i++)
	{
	    element = all_programs.get(i);
	    score = element.first().first();
	    n = file.size();
	    print("count ", score, "/", n, "= (", ((float(100) * float(score)) / float(n)), "%)");
	}
	print("Done sorted all_programs scores");
	print("best_from_all_programs = ", all_programs.get(0).first().first());

    return all_programs.get(0).first().second();
}

/*

bit composite_predicate(x)
{
    if(condition(x))
    {
        return composite_predicate(x);
    }
    else
    {
        return program_lvl0();
    }
}

*/


hypersketch recursive_program_constructor(int stun_depth, file, num_trials, num_rows_per_sample, local_sketch_main, local_sketch_main__Wrapper)
{

    harness_levels = [];

    for(int i = 0;i<stun_depth;i++)
    {
        if(i == 0)
        {
            print("num_holes(i =", i, "): ", local_sketch_main__Wrapper.num_holes());
            mhw_lvl0 = best_effort_synthesized_program(local_sketch_main__Wrapper, file, num_trials, num_rows_per_sample);

            print("after best_effort, i", i);

            harness_levels.append(mhw_lvl0);

        }
        else
        {

            print("ENTERING i =", i);

            assert(i >= 1);

            print("composite_predicate.num_holes();", composite_predicate.num_holes());

            cp_lvl_i = composite_predicate.deep_clone();

            print("cp_lvl_i.num_holes();", cp_lvl_i.num_holes());

            cp_lvl_i.replace("composite_predicate", harness_levels[i-1].get("sketch_main").get("composite_predicate"));

            local_sketch_main.replace("composite_predicate", cp_lvl_i);

            print("num_holes(i =", i, "): ", local_sketch_main__Wrapper.num_holes());

            mhw_lvl_i = best_effort_synthesized_program(local_sketch_main__Wrapper, file, num_trials, num_rows_per_sample);

            harness_levels.append(mhw_lvl_i);
        }

        if(false)
        {
            to_eval = eval_program_main.produce_replace("dummy_program", harness_levels[i].get("sketch_main").get("composite_predicate"));
            to_eval = to_eval.produce_executable();

            local_file = File(file_name, to_eval);
            for(int k = 0;k < local_file.size(); k++)
            {
                if(to_eval.passes(local_file[k])){
                    //print("composite_predicate(file[", k, "]) passes");
                    print("composite_predicate(file[", k, "]) = ", to_eval(local_file[k]));
                }
                else
                {
                    print("composite_predicate(file[", k, "]) fails");
                }
            }
        }

        score = harness_levels[i].vectorized_count_passing_inputs(file);

        print("score[", i, "] =", score);
    }

    return harness_levels[stun_depth-1];
}

hypersketch recursive_function_stun_for_benchmarking()
{
    local_sketch_main = sketch_main.deep_clone();
    local_sketch_main__Wrapper = sketch_main__Wrapper.produce_replace("sketch_main", local_sketch_main);

    File file = File(file_name, local_sketch_main__Wrapper);

    num_trials = 1;
    num_rows_per_sample = 1;

    int stun_depth = 15;

    recursive_program = recursive_program_constructor(stun_depth, file, num_trials, num_rows_per_sample, local_sketch_main, local_sketch_main__Wrapper);

    return recursive_program;
}

hypersketch recursive_function_stun()
{

    local_sketch_main = sketch_main.deep_clone();
    local_sketch_main__Wrapper = sketch_main__Wrapper.produce_replace("sketch_main", local_sketch_main);

    File file = File(file_name, local_sketch_main__Wrapper);

    num_trials = 15;
    num_rows_per_sample = 3;

    int stun_depth = 3;

    recursive_program = recursive_program_constructor(stun_depth, file, num_trials, num_rows_per_sample, local_sketch_main, local_sketch_main__Wrapper);

    check_harness_levels = [];

    for(int i = 0;i<stun_depth;i++)
    {
        cp_lvl_i = composite_predicate.deep_clone();
        cp_lvl_i.replace("composite_predicate", cp_lvl_i);

        print("num_holes(i=", i, "j=", 0, "): ", cp_lvl_i.num_holes());

        for(int j = 0; j<i;j++)
        {
            print("i, j, (j<i)", i, j, (j<i));
            assert((j < i), "fails: ", j, "!<", i);
            assert(not(j == i), "fails: ", j, "!!=", i);


            next_cp_lvl_i = composite_predicate.deep_clone();
            next_cp_lvl_i.replace("composite_predicate", cp_lvl_i);
            print("num_holes(i=", i, "j=", j+1, "): ", next_cp_lvl_i.num_holes());
            cp_lvl_i = next_cp_lvl_i;
        }

        print("num_holes(i =", i, "): ", cp_lvl_i.num_holes());

        intermediate_solutions = [];

        print("TRY intermediate_solutions.append(recursive_program.get_solution()); i = ", i);
        intermediate_solutions.append(recursive_program.get_solution());
        print("DONE intermediate_solutions.append(recursive_program.get_solution()); i = ", i);

        print("TRY intermediate_solutions.append(recursive_program.get('sketch_main').get_solution()); i = ", i);
        intermediate_solutions.append(recursive_program.get("sketch_main").get_solution());
        print("DONE intermediate_solutions.append(recursive_program.get('sketch_main').get_solution()); i = ", i);

        at_level = recursive_program.get("sketch_main").get("composite_predicate");

        local_depth = (stun_depth-i)-1;
        for(int j = 0; j<local_depth; j++) {
            print("TRY intermediate_solutions.append(at_level.get_solution()); i, j = ", i, j, "/ ", local_depth);
            intermediate_solutions.append(at_level.get_solution());
            print("DONE intermediate_solutions.append(at_level.get_solution()); i, j = ", i, j, "/ ", local_depth);

            at_level = at_level.get("composite_predicate");
        }

        // can't do this bc different holes are aliased.
        cp_lvl_i.make_executable(at_level.get_solution());


        //START
        print("cp_lvl_i, i =", i);
        local_sketch_main.replace("composite_predicate", cp_lvl_i);

        if(false){
            to_eval = eval_program_main.produce_replace("dummy_program", cp_lvl_i);
            to_eval = to_eval.produce_executable();

            local_file = File(file_name, to_eval);
            for(int k = 0;k < local_file.size(); k++)
            {
                if(to_eval.passes(local_file[k])){
                    //print("composite_predicate(file[", k, "]) passes");
                    print("composite_predicate(file[", k, "]) = ", to_eval(local_file[k]));
                }
                else
                {
                    print("composite_predicate(file[", k, "]) fails");
                }
            }
        }

        score_predicted = local_sketch_main__Wrapper.produce_executable().vectorized_count_passing_inputs(file);
        //END

        //START
        print("at_level, i =", i);
        local_sketch_main.replace("composite_predicate", at_level);

        if(false){
            to_eval = eval_program_main.produce_replace("dummy_program", at_level);
            to_eval = to_eval.produce_executable();

            local_file = File(file_name, to_eval);
            for(int k = 0;k < local_file.size(); k++)
            {
                if(to_eval.passes(local_file[k])){
                    //print("composite_predicate(file[", k, "]) passes");
                    print("composite_predicate(file[", k, "]) = ", to_eval(local_file[k]));
                }
                else
                {
                    print("composite_predicate(file[", k, "]) fails");
                }
            }
        }

        score_ground_truth = local_sketch_main__Wrapper.produce_executable().vectorized_count_passing_inputs(file);
        //END

        print("score_ground_truth == score_predicted:: ", score_ground_truth, " == ", score_predicted);
        assert(score_ground_truth == score_predicted, "FAILED: score_ground_truth == score_predicted:: ", score_ground_truth, " != ", score_predicted);

        check_harness_levels.append(local_sketch_main__Wrapper.deep_clone());
    }

    local_sketch_main.reset("composite_predicate");

    return check_harness_levels[stun_depth-1];
    return check_harness_levels[stun_depth-1].get_solution();
}

hypersketch left_and_right_and_cond_synthesis_sketch_main()
{
    //first sample base level
    //choose best
    //sample left and right
    //choose best

    num_trials = 10;
    num_rows_per_sample = 6;
    select_best = 5;

    string file_name = "uav_kg_big__as_bools.data";

    file = File(file_name, sketch_main_lvl0_left__Wrapper);
    lvl0_left_solutions = best_effort_solutions(sketch_main_lvl0_left__Wrapper, file, num_trials, num_rows_per_sample);

    file = File(file_name, sketch_main_lvl0_right__Wrapper);
    lvl0_right_solutions = best_effort_solutions(sketch_main_lvl0_right__Wrapper, file, num_trials, num_rows_per_sample);

    print("first lvl0_left_solutions.size() ", lvl0_left_solutions.size());
    print("first lvl0_right_solutions.size() ", lvl0_right_solutions.size());

    predicate_lvl0_left_original = predicate_lvl0_left.unit_clone();
    predicate_lvl0_right_original = predicate_lvl0_right.unit_clone();

    any ret;

    {
        all_compound_solutions = [];

        print("lvl0_left_solutions.size() ", lvl0_left_solutions.size());
        print("lvl0_right_solutions.size() ", lvl0_right_solutions.size());
        for(i = 0;i<select_best;i++)
        {
            predicate_lvl0_left.make_executable(lvl0_left_solutions.get(i).second());
            for(j = 0;j<select_best; j++)
            {
                predicate_lvl0_right.make_executable(lvl0_right_solutions.get(j).second());

                any compound_solutions;
                {
                    file = File(file_name, sketch_main_lvl1__Wrapper);
                    compound_solutions = best_effort_solutions(sketch_main_lvl1__Wrapper, file, num_trials, num_rows_per_sample);
                    //file.clear();
                }

                //this is not intuitive
                n_compound_solutions = compound_solutions.size();
                for(k = 0;k<n_compound_solutions; k++)
                {
                    compound_solutions.get(k).second().join(lvl0_left_solutions.get(i).second());
                    compound_solutions.get(k).second().join(lvl0_right_solutions.get(j).second());
                }

                concatenate(all_compound_solutions, compound_solutions);

                //predicate_lvl0_right.clear();
                predicate_lvl0_right = predicate_lvl0_right_original.unit_clone();
            }

            //predicate_lvl0_left.clear();
            predicate_lvl0_left = predicate_lvl0_left_original.unit_clone();
        }

        all_compound_solutions.sort();
        all_compound_solutions.reverse();

        ret = all_compound_solutions.get(0).second();
    }

    //predicate_lvl0_left.clear();
    predicate_lvl0_left = predicate_lvl0_left_original;
    //predicate_lvl0_right.clear();
    predicate_lvl0_right = predicate_lvl0_right_original;

    return ret;
}

hypersketch get_score(SketchFunction harness3, Solution solution, File file)
{
    SketchFunction program = harness3.produce_executable(solution); // create a program that uses the solution to fill in the holes of the harness.
    int score2 = program.vectorized_count_passing_inputs(file); // count how many input-output examples are solved with this solution
    program.clear();
    return score2;
}

/*

hypersketch Solution original_sketch_main()
{
    return beam_search_sketch_main();
    //return repeat_greedy_sketch_main();
    //return stun_main();
}

hypersketch Solution beam_search_sketch_main()
{
    string file_name = "uav_kg_big__as_bools.data";

    File file = File(file_name, sketch_main_lvl0__Wrapper); //unnatural, remove harness
    int total_num_rows = file.size();

    int num_trials = 10;
    int num_rows_per_sample = 6;
    int beam_breath = 3;

    vector<pair<int, Solution> > best_effort_solutions =
        best_effort_solutions(sketch_main_lvl0__Wrapper, file, num_trials, num_rows_per_sample);

    vector<pair<int, pair<int, Solution> > > indexed_solutions = vector<pair<int, pair<int, Solution> > >();
    //use python syntax for arrays

    int best_effort_solutions_size = best_effort_solutions.size();
    pair<int, Solution> element;
    for(int i = 0; i<best_effort_solutions_size; i++)
    {
        element = best_effort_solutions.get(i);
        indexed_solutions.append(
            pair<int, pair<int, Solution> >(
                element.first(), pair<int, Solution>(0, element.second())));
    }

    indexed_solutions.sort();
    indexed_solutions.reverse();

    int num_candidates = indexed_solutions.size();
    SketchFunction harness4;
    vector<pair<int, pair<int, Solution> > > next_frontier = vector<pair<int, pair<int, Solution> > >();
    int local_n;
    int j;
    Solution tmp_solution;
    Solution partial_solution;
    SketchFunction throw_away;
    for(i = 0;i<beam_breath;i++)
    {
        harness4 = sketch_main_lvl1__Wrapper.unit_clone();
        assert(indexed_solutions.get(i).second().first() == 0);
        partial_solution = indexed_solutions.get(i).second().second();
        harness4.make_executable(partial_solution);
        file = File(file_name, harness4);
        best_effort_solutions = best_effort_solutions(harness4, file, num_trials, num_rows_per_sample);

        local_n = best_effort_solutions.size();

        for(j = 0;j<local_n;j++)
        {
            tmp_solution = partial_solution.unit_clone();
            tmp_solution.join(best_effort_solutions.get(j).second());
            next_frontier.append(
                pair<int, pair<int, Solution> >(
                    best_effort_solutions.get(j).first(),
                    pair<int, Solution>(1, tmp_solution)));
        }
        harness4.clear();
    }


    next_frontier.sort();
    next_frontier.reverse();


    num_candidates = next_frontier.size();
    vector<pair<int, pair<int, Solution> > > final_frontier = vector<pair<int, pair<int, Solution> > >();
    int counter = 0;
    for(i = 0;i<beam_breath;i++)
    {
        harness4 = sketch_main_lvl2__Wrapper.unit_clone();
        assert(next_frontier.get(i).second().first() == 1);
        partial_solution = next_frontier.get(i).second().second();
        harness4.make_executable(partial_solution);
        file = File(file_name, harness4);
        best_effort_solutions = best_effort_solutions(harness4, file, num_trials, num_rows_per_sample);

        local_n = best_effort_solutions.size();

        for(j = 0;j<local_n;j++)
        {
            tmp_solution = partial_solution.unit_clone();
            tmp_solution.join(best_effort_solutions.get(j).second());
            final_frontier.append(
                pair<int, pair<int, Solution> >(
                    best_effort_solutions.get(j).first(),
                    pair<int, Solution>(2, tmp_solution)));
            counter++;
            print("score ", best_effort_solutions.get(j).first(), " counter ", counter);
        }
        harness4.clear();
    }

    final_frontier.sort();
    final_frontier.reverse();

    assert(final_frontier.size() > 0);

    Solution ret_solution = final_frontier.get(0).second().second();

    return ret_solution;
}

hypersketch Solution repeat_greedy_sketch_main()
{
    string file_name = "/Users/klimentserafimov/CLionProjects/sketch-backend/src/SketchSolver/InputParser/solver_language__test_files/zig_zag.data";
    File file = File(file_name, sketch_main_lvl2__Wrapper);
    int n = file.size();


    Solution sol = stun_main();
    int score = get_score(sketch_main_lvl2__Wrapper, sol, file);
    print("at_score ", score, "/", n);
    while(score < n)
    {
        seed++;
        sol = stun_main();
        score = get_score(sketch_main_lvl2__Wrapper, sol, file);
        print("at_score ", score, "/", n);
    }

    return sol;
}

*/

hypersketch stun_main()
{
	int num_trials = 20; //hyperparameter
	int num_rows = 6; //hyperparameter

    Solution total_solution = Solution();

    SketchFunction org_program_lvl0 = program_lvl0.unit_clone();
    SketchFunction org_program_lvl1 = program_lvl1.unit_clone();
    SketchFunction org_program_lvl2 = program_lvl2.unit_clone();

    SketchFunction tmp_program_lvl0 = program_lvl0;
    SketchFunction tmp_program_lvl1 = program_lvl1;
    SketchFunction tmp_program_lvl2 = program_lvl2;

    program_lvl0 = org_program_lvl0;
    program_lvl1 = org_program_lvl1;
    program_lvl2 = org_program_lvl2;

	//solve the harness lvl0
	File file = File(file_name, main_lvl0__Wrapper); // The dataset is stored in a File; File is a native construct.
	print("main_lvl0__Wrapper.num_holes() = ", main_lvl0__Wrapper.num_holes());
	Solution solution_lvl0 = best_effort_synthesis(main_lvl0__Wrapper, file, num_trials, num_rows);
    total_solution.join(solution_lvl0);

	//concretize the predicate lvl0
	program_lvl0.make_executable(solution_lvl0);

	//solve the harness lvl1
	file = File(file_name, main_lvl1__Wrapper);
	print("main_lvl1__Wrapper.num_holes() = ", main_lvl1__Wrapper.num_holes());
	Solution solution_lvl1 = best_effort_synthesis(main_lvl1__Wrapper, file, num_trials, num_rows);
    total_solution.join(solution_lvl1);

	//concretize the predicate lvl1
	program_lvl1.make_executable(solution_lvl1);

	//solve the harness lvl2
	file = File(file_name, main_lvl2__Wrapper);
	print("main_lvl2__Wrapper.num_holes() = ", main_lvl2__Wrapper.num_holes());
	Solution solution_lvl2 = best_effort_synthesis(main_lvl2__Wrapper, file, num_trials, num_rows);
    total_solution.join(solution_lvl2);

	//concretize the predicate lvl2
	program_lvl2.make_executable(solution_lvl2);

	//done, no more predicates to concretize.


    program_lvl0 = tmp_program_lvl0;
    program_lvl1 = tmp_program_lvl1;
    program_lvl2 = tmp_program_lvl2;

	return total_solution;
}

hypersketch best_effort_solutions(SketchFunction harness5, File file, int num_trials, int num_rows) {

	Solution best_solution;
	int best_score = 0;

    File subset_file;
    Solution solution;
    SketchFunction program;
    int score;

    vector<pair<int, Solution> > solutions = vector<pair<int, Solution> >();
    for(int trial_id = 0; trial_id<num_trials; trial_id++)
	{
		subset_file = file.produce_subset_file(num_rows); //sample subset of the rows
		solution = SATSolver(harness5.deep_clone(), subset_file); // invoke the Sketch hypersketch on the harness
		subset_file.clear();
		score = get_score(harness5, solution, file);
		print("TRIAL", trial_id+1, "/", num_trials, "SCORE", score, "/", file.size());
		solutions.append(pair<int, Solution>(score, solution));
		if(score > best_score) // update the best_solution
		{
			best_solution = solution;
			best_score = score;
		}
	}

	solutions.sort();
	solutions.reverse();

	print("Sorted solution scores:");

	int solutions_size = solutions.size();

    pair<int, Solution> element;
	for(int i = 0; i<solutions_size; i++)
	{
	    element = solutions.get(i);
	    print("count ", element.first(), "/", file.size(), "= (", ((float(100) * float(element.first())) / float(file.size())), "%)");
	}
	print("Done sorted solution scores");

	print("best_score = ", best_score);

    assert(solutions.size() == num_trials);

    print("ASSERTED TRUE:", "solutions.size()", solutions.size(), "num_trials", num_trials);

    return solutions;
}

hypersketch best_effort_synthesis(SketchFunction harness6, File file, int num_trials, int num_rows) {
    vector<pair<int, Solution> > solutions = best_effort_solutions(harness6, file, num_trials, num_rows);
    int solutions_size = solutions.size();
    Solution ret = solutions.get(0).second();
	return ret;
}

/*
//subroutine to count the number of passing input-output examples.
hypersketch int count_passing_inputs(SketchFunction program, File file)
{
	int score = 0;
	int row_id = 0;
	int n = file.size();
    Input input;
    bool success;
	while(row_id < n){
	    input = file.get(row_id);
		success = program.passes(input);
		if(success == true){
		    score = score + 1;
		}
		row_id++;
	}
	print("count_passing_inputs returns", score);
	return score;
}*/

Solver concatenate(arr1, arr2)
{
    n = arr2.size();
    for(i = 0;i<n;i++)
    {
        arr1.append(arr2.get(i));
    }
}

/*
generator int program_generator(int x) {
    //USER DEFINED
};

generator bit predicate_generator(int x)
{
    //USER DEFINED
}

bit predicate(int x)
{
    return predicate_generator(x);
}

bit condition(int x) {return 0;}

int if_true_branch(int x) {return 0;}

int if_false_branch(int x) {return 0;}

int composite_predicate(int x) {
    if(condition(x)) {
        return if_true_branch(x);
    }
    else {
        return if_false_branch(x);
    }
}

bit program_lvl0(int x) {
    return line(x);
}

int dummy_program(int x) {return 1;}

@FromFile("zig_zag.data")
harness void sketch_main(int x, bit out)
{
    assert(dummy_program(x) == out);
}

@FromFile("zig_zag.data")
harness void eval_predicate_main(int x, bit out)
{
    bit one = 1;
    assert(dummy_program(x) == one);
}

@FromFile("zig_zag.data")
harness void dummy_sketch_main(int x, bit out)
{
    assert(program(x) == 0);
    assert(program_lvl0(x) == out);
    assert(composite_predicate(x) == out);
}
*/

Solver best_effort_programs(harness1, file, num_trials, num_rows_per_sample)
{
    solutions = best_effort_solutions(harness1, file, num_trials, num_rows_per_sample);
    programs = [];
    for(int i = 0;i<solutions.size();i++)
    {
        programs.append(pair<int, SketchFunction>(solutions.get(i).first(), harness1.produce_concretization(solutions.get(i).second())));
    }
    return programs;
}

Solver best_effort_synthesized_program(harness2, file, num_trials, num_rows_per_sample)
{
    return harness2.produce_concretization(
        best_effort_synthesis(harness2, file, num_trials, num_rows_per_sample));
}

Solver main()
{
    //return top_down_and_bottom_up_synthesis_sketch_main();
    return recursive_function_stun();


    //return recursive_function_stun_reconstructing_inlined_non_concretized_function_with_replaced_ports();
    //return stun_main();
    //return left_and_right_and_cond_synthesis_sketch_main();
}

Solver synthesize_composite_programs_from_parts(left_programs, right_programs, select_best, file_name, num_trials, num_rows_per_sample)
{
    seed_main_lvl1 = [];

    assert(left_programs.size() >= select_best, "FAILED: left_programs.size() <= select_best");
    assert(right_programs.size() >= select_best, "FAILED: right_programs.size() <= select_best");

    for(int i = 0;i<select_best;i++) {
        for(int j = 0;j<select_best;j++) {
            print("LEFT", i+1, "/", select_best, "RIGHT", j+1, "/", select_best);

            //composite_predicate.replace("condition", condition);
            //composite_predicate.replace("if_true_branch", if_true_branch);
            //composite_predicate.replace("if_false_branch", if_false_branch);

            //assert(composite_predicate.num_holes() == 3, "cp has", composite_predicate.num_holes());

            predicate_lvl1 = composite_predicate.produce_replace("condition", predicate.clone());
            print("predicate_lvl1.num_holes()", predicate_lvl1.num_holes());
            int prev_num_holes = predicate_lvl1.num_holes();

            tmp = program_lvl0.produce_concretization(left_programs.get(i).second()["sketch_main"]["dummy_program"].get_solution());
            print("tmp.num_holes()", tmp.num_holes());
            int new_num_holes = tmp.num_holes();

            predicate_lvl1.replace("if_true_branch", tmp);
            print("predicate_lvl1.num_holes()", predicate_lvl1.num_holes());
            assert((prev_num_holes + new_num_holes) >= predicate_lvl1.num_holes(), prev_num_holes, "+", new_num_holes, "<", predicate_lvl1.num_holes());

            tmp = program_lvl0.produce_concretization(right_programs.get(j).second()["sketch_main"]["dummy_program"].get_solution());
            print("tmp.num_holes()", tmp.num_holes());

            predicate_lvl1.replace("if_false_branch", tmp);
            print("predicate_lvl1.num_holes()", predicate_lvl1.num_holes());

            sketch_main_lvl1_sub = sketch_main.produce_replace("dummy_program", predicate_lvl1);
            print("sketch_main_lvl1_sub.num_holes()", sketch_main_lvl1_sub.num_holes());


            sketch_main_lvl1 = sketch_main__Wrapper.produce_replace("sketch_main", sketch_main_lvl1_sub);
            print("sketch_main_lvl1.num_holes()", sketch_main_lvl1.num_holes());

            File file = File(file_name, sketch_main_lvl1);
            local_sketch_main_lvl1_programs = best_effort_programs(sketch_main_lvl1, file, num_trials, num_rows_per_sample);

            tmp = [];

            for(int k = 0; k < local_sketch_main_lvl1_programs.size();k++)
            {
                tmp.append(
                    pair<pair<int, SketchFunction>, pair<pair<int, SketchFunction>, pair<int, SketchFunction> > >(
                        local_sketch_main_lvl1_programs.get(k),
                        pair<pair<int, SketchFunction>, pair<int, SketchFunction> >(
                            left_programs.get(i),
                            right_programs.get(j))));
            }

            local_sketch_main_lvl1_programs = tmp;

            concatenate(seed_main_lvl1, local_sketch_main_lvl1_programs);
        }
    }

    seed_main_lvl1.sort();
    seed_main_lvl1.reverse();

    assert(seed_main_lvl1.size() == ((select_best*select_best)*num_trials), "FAILED: seed_main_lvl1.size() == (select_best*select_best)");

    return seed_main_lvl1;
}

Solver top_down_and_bottom_up_synthesis_sketch_main()
{
    //for now these are passed as parameters from the sketch.
    //the sketch follows a constraint that the file_names should be the same

    num_trials = 1;
    num_rows_per_sample = 3;
    select_best = 1;
    assert(num_trials >= select_best);

    sketch_main_lvl0_sub = sketch_main.produce_replace("dummy_program", program_lvl0.clone());
    sketch_main_lvl0 = sketch_main__Wrapper.produce_replace("sketch_main", sketch_main_lvl0_sub);

    File file = File(file_name, sketch_main_lvl0);
    left_lvl0_programs = best_effort_programs(sketch_main_lvl0, file, num_trials, num_rows_per_sample);
    print("DONE left_lvl0_programs");
    right_lvl0_programs = best_effort_programs(sketch_main_lvl0, file, num_trials, num_rows_per_sample);
    print("DONE right_lvl0_programs");

    assert(left_lvl0_programs.size() >= select_best);
    assert(right_lvl0_programs.size() >= select_best);

    seed_main_lvl1 = synthesize_composite_programs_from_parts(left_lvl0_programs, right_lvl0_programs, select_best, file_name, num_trials, num_rows_per_sample);

    all_programs = [];
    concatenate(all_programs, seed_main_lvl1);


    improved_main_lvl1 = [];

    int prev_best = 0-1;
    int new_best = seed_main_lvl1.get(0).first().first();

    assert(num_trials >= select_best, "fails:", num_trials, "!>=", select_best);

    int iter_id = 0;


    if(false)
    {
        num_trials = 4;
        num_rows_per_sample = 6;
        select_best = 2;
        assert(num_trials >= select_best);
    }
    while(new_best > prev_best)
    {
        print("NEW_ITERATION", iter_id);
        print("prev_best", prev_best, "new_best", new_best);

        prev_best = new_best;
        new_best = 0;

        for(int i = 0; i<seed_main_lvl1.size();i++)
        {
            improved_main_lvl1.append(seed_main_lvl1.get(i));
        }

        if(seed_main_lvl1.size() < select_best)
        {
            select_best = seed_main_lvl1.size();
        }

        outer_loop_select_best = select_best;

        if(outer_loop_select_best > seed_main_lvl1.size())
        {
            outer_loop_select_best = seed_main_lvl1.size();
        }

        assert(seed_main_lvl1.size() >= outer_loop_select_best, "FAILED: seed_main_lvl1.size() >= select_best");


        for(int i = 0;i<outer_loop_select_best;i++)
        {
            print("start i =", i+1, "/", outer_loop_select_best);
            print("prev_score: ", seed_main_lvl1.get(i).first().first());
            local_program = seed_main_lvl1.get(i).first().second();
            //take condition
            //condition_lvl1_sub_sub = predicate.produce_concretization(local_program.get_solution());
            condition_lvl1_sub_sub = predicate.produce_concretization(local_program["sketch_main"]["dummy_program"]["condition"].get_solution());
            condition_lvl1_sub = eval_program_main.produce_replace("dummy_program", condition_lvl1_sub_sub).produce_concretization();
            condition_lvl1 = eval_program_main__Wrapper.produce_replace("eval_program_main", condition_lvl1_sub);

            File file = File(file_name, condition_lvl1_sub);
            //split file based on condition
            if_true_file = file.produce_filter(lambda[condition_lvl1_sub](x){
                return condition_lvl1_sub(x);});
            if_false_file = file.produce_filter(lambda[condition_lvl1_sub](x){
                return not(condition_lvl1_sub(x));});

            print("if_true_file.size()", if_true_file.size());
            print("if_false_file.size()", if_false_file.size());

            bool entered = false;
            if(if_true_file.size() >= num_rows_per_sample) {
                if(if_false_file.size() >= num_rows_per_sample) {
                    entered = true;
                    print("ENTER i", i);
                    assert(if_true_file.size() >= num_rows_per_sample, "FAILED: if_true_file.size() >= num_rows_per_sample");
                    assert(if_false_file.size() >= num_rows_per_sample, "FAILED: if_false_file.size() >= num_rows_per_sample");
                    assert((if_true_file.size()+if_false_file.size()) == file.size(), "FAILED: if_true_file.size()+if_false_file.size() == file.size()");

                    //resynthesize lvl0 left and right predicates.

                    left_tmp = sketch_main.produce_replace("dummy_program", program_lvl0.clone());
                    left_sketch_main_lvl0 = sketch_main__Wrapper.produce_replace("sketch_main", left_tmp);
                    if_true_file.relabel(left_sketch_main_lvl0);
                    left_sketch_main_lvl0_programs =
                        best_effort_programs(left_sketch_main_lvl0, if_true_file, num_trials, num_rows_per_sample);
                    print("DONE (i = ", i, ") left_sketch_main_lvl0_programs");
                    left_sketch_main_lvl0_programs.append(seed_main_lvl1.get(i).second().first());
                    left_sketch_main_lvl0_programs.sort();
                    left_sketch_main_lvl0_programs.reverse();

                    right_tmp = sketch_main.produce_replace("dummy_program", program_lvl0.clone());
                    right_sketch_main_lvl0 = sketch_main__Wrapper.produce_replace("sketch_main", right_tmp);
                    if_false_file.relabel(right_sketch_main_lvl0);
                    right_sketch_main_lvl0_programs = best_effort_programs(right_sketch_main_lvl0, if_false_file, num_trials, num_rows_per_sample);
                    print("DONE (i = ", i, ") right_sketch_main_lvl0_programs");
                    right_sketch_main_lvl0_programs.append(seed_main_lvl1.get(i).second().second());
                    right_sketch_main_lvl0_programs.sort();
                    right_sketch_main_lvl0_programs.reverse();

                    //combine with condition

                    new_best_predicate_lvl1 = composite_predicate.produce_replace("condition", condition_lvl1_sub_sub);
                    new_best_predicate_lvl1.replace("if_true_branch",
                        program_lvl0.produce_concretization(left_sketch_main_lvl0_programs.get(0).second()["sketch_main"]["dummy_program"].get_solution()));
                    new_best_predicate_lvl1.replace("if_false_branch",
                        program_lvl0.produce_concretization(right_sketch_main_lvl0_programs.get(0).second()["sketch_main"]["dummy_program"].get_solution()));

                    new_best_sketch_main_lvl1_sub = sketch_main.produce_replace("dummy_program", new_best_predicate_lvl1);
                    new_best_sketch_main_lvl1 = sketch_main__Wrapper.produce_replace("sketch_main", new_best_sketch_main_lvl1_sub);

                    solution = new_best_sketch_main_lvl1.get_solution();

                    file = File(file_name, new_best_sketch_main_lvl1);
                    dag_for_score = new_best_sketch_main_lvl1.produce_concretization();
                    int score = count_passing_inputs(dag_for_score, file);

                    print("new_score:", score);

                    improved_main_lvl1.append(
                        pair<pair<int, SketchFunction>, pair<pair<int, SketchFunction>, pair<int, SketchFunction> > >(
                            pair<int, SketchFunction>(score, new_best_sketch_main_lvl1),
                            pair<pair<int, SketchFunction>, pair<int, SketchFunction> >(
                                left_sketch_main_lvl0_programs.get(0),
                                right_sketch_main_lvl0_programs.get(0))));


                    //commented out in ordeer to test the existence of solutions in the very previous statement.
                    if(false){
                        new_synthesized_lvl1 =
                            synthesize_composite_programs_from_parts(
                                left_sketch_main_lvl0_programs, right_sketch_main_lvl0_programs,
                                select_best, file_name, num_trials, num_rows_per_sample);

                        print("DONE (i = ", i, ") new_synthesized_lvl1");

                        print("synthesized_best_score: ", new_synthesized_lvl1.get(0).first().first());

                        concatenate(improved_main_lvl1, new_synthesized_lvl1);
                    }
                }
            }
            if(not(entered))
            {
                if(outer_loop_select_best < seed_main_lvl1.size())
                {
                    outer_loop_select_best = outer_loop_select_best+1;
                }
            }
            print("DONE i =", i, "FINAL");
        }

        improved_main_lvl1.sort();
        improved_main_lvl1.reverse();

        print("SORTED");

        new_best = improved_main_lvl1.get(0).first().first();
        print("new_best:", new_best);
        seed_main_lvl1 = improved_main_lvl1;
        improved_main_lvl1 = [];
        concatenate(all_programs, seed_main_lvl1);

        all_programs.sort();
        all_programs.reverse();

        for(int i = 0; i<all_programs.size(); i++)
        {
            element = all_programs.get(i);
            score = element.first().first();
            n = file.size();
            print("count ", score, "/", n, "= (", ((float(100) * float(score)) / float(n)), "%)");
        }
        print("Done sorted all_programs scores");
        print("best_from_all_programs = ", all_programs[0].first().first());

        print("UPDATED seed_main_lvl1");
    }


    assert(new_best == prev_best);

    all_programs.sort();
    all_programs.reverse();

    assert(seed_main_lvl1.size() >= 1);
    assert(all_programs.size() >= 1);
    assert(all_programs.size() >= seed_main_lvl1.size());
    assert(all_programs.get(0).first().first() == seed_main_lvl1.get(0).first().first());

	for(int i = 0; i<all_programs.size(); i++)
	{
	    element = all_programs.get(i);
	    score = element.first().first();
	    n = file.size();
	    print("count ", score, "/", n, "= (", ((float(100) * float(score)) / float(n)), "%)");
	}
	print("Done sorted all_programs scores");
	print("best_from_all_programs = ", all_programs.get(0).first().first());

    return all_programs.get(0).first().second();
}

/*

bit composite_predicate(x)
{
    if(condition(x))
    {
        return composite_predicate(x);
    }
    else
    {
        return program_lvl0();
    }
}

*/


Solver recursive_function_stun_reconstructing_inlined_non_concretized_function_with_replaced_ports()
{

    File file = File(file_name, sketch_main__Wrapper);

    num_trials = 10;
    num_rows_per_sample = 3;

    cp = composite_predicate.clone();
    cp = composite_predicate.produce_replace("composite_predicate", cp);
    cp = composite_predicate.produce_replace("composite_predicate", cp);

    cp = cp.produce_concretization();

    print("HERE -1");
    cp = composite_predicate.produce_replace("composite_predicate", cp.get("composite_predicate"));
    print("HERE -2");
    cp = composite_predicate.produce_replace("composite_predicate", cp);
    cp = composite_predicate.produce_replace("composite_predicate", cp);

    cp = cp.produce_concretization();

    print("HERE >>>>>>>>>>> A");
    cp = cp.get("composite_predicate");
    print("HERE >>>>>>>>>>> DONE A");

    sk_main = sketch_main.produce_replace("composite_predicate", cp);

    sk_main_wrapper = sketch_main__Wrapper.produce_replace("sketch_main", sk_main);

    return best_effort_synthesized_program(sk_main_wrapper, file, num_trials, num_rows_per_sample);
}


Solver recursive_program_constructor(int stun_depth, file, num_trials, num_rows_per_sample, local_sketch_main, local_sketch_main__Wrapper)
{

    harness_levels = [];

    for(int i = 0;i<stun_depth;i++)
    {
        if(i == 0)
        {
            print("num_holes(i =", i, "): ", local_sketch_main__Wrapper.num_holes());
            mhw_lvl0 = best_effort_synthesized_program(local_sketch_main__Wrapper, file, num_trials, num_rows_per_sample);

            print("after best_effort, i", i);

            harness_levels.append(mhw_lvl0);

        }
        else
        {

            print("ENTERING i =", i);

            assert(i >= 1);

            print("composite_predicate.num_holes();", composite_predicate.num_holes());

            cp_lvl_i = composite_predicate.deep_clone();

            print("cp_lvl_i.num_holes();", cp_lvl_i.num_holes());

            cp_lvl_i.replace("composite_predicate", harness_levels[i-1].get("sketch_main").get("composite_predicate"));

            local_sketch_main.replace("composite_predicate", cp_lvl_i);

            print("num_holes(i =", i, "): ", local_sketch_main__Wrapper.num_holes());

            mhw_lvl_i = best_effort_synthesized_program(local_sketch_main__Wrapper, file, num_trials, num_rows_per_sample);

            harness_levels.append(mhw_lvl_i);
        }

        if(true)
        {
            to_eval = eval_program_main_harness.produce_replace("dummy_program", harness_levels[i].get("sketch_main").get("composite_predicate"));
            to_eval = to_eval.produce_concretization();

            local_file = File(file_name, to_eval);
            for(int k = 0;k < local_file.size(); k++)
            {
                if(to_eval.passes(local_file[k])){
                    //print("composite_predicate(file[", k, "]) passes");
                    print("composite_predicate(file[", k, "]) = ", to_eval(local_file[k]));
                }
                else
                {
                    print("composite_predicate(file[", k, "]) fails");
                }
            }
        }

        score = count_passing_inputs(harness_levels[i], file);

        print("score[", i, "] =", score);
    }

    return harness_levels[stun_depth-1];
}



Solver recursive_function_stun()
{

    local_sketch_main = sketch_main.deep_clone();
    local_sketch_main__Wrapper = sketch_main__Wrapper.produce_replace("sketch_main", local_sketch_main);

    File file = File(file_name, local_sketch_main__Wrapper);

    num_trials = 2;
    num_rows_per_sample = 3;

    int stun_depth = 3;

    recursive_program = recursive_program_constructor(stun_depth, file, num_trials, num_rows_per_sample, local_sketch_main, local_sketch_main__Wrapper);

    check_harness_levels = [];

    for(int i = 0;i<stun_depth;i++)
    {
        cp_lvl_i = composite_predicate.deep_clone();
        cp_lvl_i.replace("composite_predicate", cp_lvl_i);

        print("num_holes(i=", i, "j=", 0, "): ", cp_lvl_i.num_holes());

        for(int j = 0; j<i;j++)
        {
            print("i, j, (j<i)", i, j, (j<i));
            assert((j < i), "fails: ", j, "!<", i);
            assert(not(j == i), "fails: ", j, "!!=", i);


            next_cp_lvl_i = composite_predicate.deep_clone();
            next_cp_lvl_i.replace("composite_predicate", cp_lvl_i);
            print("num_holes(i=", i, "j=", j+1, "): ", next_cp_lvl_i.num_holes());
            cp_lvl_i = next_cp_lvl_i;
        }

        print("num_holes(i =", i, "): ", cp_lvl_i.num_holes());

        intermediate_solutions = [];

        print("TRY intermediate_solutions.append(recursive_program.get_solution()); i = ", i);
        intermediate_solutions.append(recursive_program.get_solution());
        print("DONE intermediate_solutions.append(recursive_program.get_solution()); i = ", i);

        print("TRY intermediate_solutions.append(recursive_program.get('sketch_main').get_solution()); i = ", i);
        intermediate_solutions.append(recursive_program.get("sketch_main").get_solution());
        print("DONE intermediate_solutions.append(recursive_program.get('sketch_main').get_solution()); i = ", i);

        at_level = recursive_program.get("sketch_main").get("composite_predicate");

        local_depth = (stun_depth-i)-1;
        for(int j = 0; j<local_depth; j++) {
            print("TRY intermediate_solutions.append(at_level.get_solution()); i, j = ", i, j, "/ ", local_depth);
            intermediate_solutions.append(at_level.get_solution());
            print("DONE intermediate_solutions.append(at_level.get_solution()); i, j = ", i, j, "/ ", local_depth);

            at_level = at_level.get("composite_predicate");
        }

        // can't do this bc different holes are aliased.
        cp_lvl_i.concretize(at_level.get_solution());


        //START
        print("cp_lvl_i, i =", i);
        local_sketch_main.replace("composite_predicate", cp_lvl_i);

        {
            to_eval = eval_program_main_harness.produce_replace("dummy_program", cp_lvl_i);
            to_eval = to_eval.produce_concretization();

            local_file = File(file_name, to_eval);
            for(int k = 0;k < local_file.size(); k++)
            {
                if(to_eval.passes(local_file[k])){
                    //print("composite_predicate(file[", k, "]) passes");
                    print("composite_predicate(file[", k, "]) = ", to_eval(local_file[k]));
                }
                else
                {
                    print("composite_predicate(file[", k, "]) fails");
                }
            }
        }

        score_predicted = count_passing_inputs(local_sketch_main__Wrapper.produce_concretization(), file);
        //END

        //START
        print("at_level, i =", i);
        local_sketch_main.replace("composite_predicate", at_level);

        {
            to_eval = eval_program_main_harness.produce_replace("dummy_program", at_level);
            to_eval = to_eval.produce_concretization();

            local_file = File(file_name, to_eval);
            for(int k = 0;k < local_file.size(); k++)
            {
                if(to_eval.passes(local_file[k])){
                    //print("composite_predicate(file[", k, "]) passes");
                    print("composite_predicate(file[", k, "]) = ", to_eval(local_file[k]));
                }
                else
                {
                    print("composite_predicate(file[", k, "]) fails");
                }
            }
        }

        score_ground_truth = count_passing_inputs(local_sketch_main__Wrapper.produce_concretization(), file);
        //END

        print("score_ground_truth == score_predicted:: ", score_ground_truth, " == ", score_predicted);
        assert(score_ground_truth == score_predicted, "FAILED: score_ground_truth == score_predicted:: ", score_ground_truth, " != ", score_predicted);

        check_harness_levels.append(local_sketch_main__Wrapper.deep_clone());
    }

    local_sketch_main.reset("composite_predicate");

    return check_harness_levels[stun_depth-1];
    return check_harness_levels[stun_depth-1].get_solution();
}

Solver left_and_right_and_cond_synthesis_sketch_main()
{
    //first sample base level
    //choose best
    //sample left and right
    //choose best

    num_trials = 10;
    num_rows_per_sample = 6;
    select_best = 5;

    //string file_name = "zig_zag.data";
    string file_name = "uav_kg_big__as_bools.data";

    file = File(file_name, sketch_main_lvl0_left__Wrapper);
    lvl0_left_solutions = best_effort_solutions(sketch_main_lvl0_left__Wrapper, file, num_trials, num_rows_per_sample);

    file = File(file_name, sketch_main_lvl0_right__Wrapper);
    lvl0_right_solutions = best_effort_solutions(sketch_main_lvl0_right__Wrapper, file, num_trials, num_rows_per_sample);

    print("first lvl0_left_solutions.size() ", lvl0_left_solutions.size());
    print("first lvl0_right_solutions.size() ", lvl0_right_solutions.size());

    predicate_lvl0_left_original = predicate_lvl0_left.clone();
    predicate_lvl0_right_original = predicate_lvl0_right.clone();

    any ret;

    {
        all_compound_solutions = [];

        print("lvl0_left_solutions.size() ", lvl0_left_solutions.size());
        print("lvl0_right_solutions.size() ", lvl0_right_solutions.size());
        for(i = 0;i<select_best;i++)
        {
            predicate_lvl0_left.concretize(lvl0_left_solutions.get(i).second());
            for(j = 0;j<select_best; j++)
            {
                predicate_lvl0_right.concretize(lvl0_right_solutions.get(j).second());

                any compound_solutions;
                {
                    file = File(file_name, sketch_main_lvl1__Wrapper);
                    compound_solutions = best_effort_solutions(sketch_main_lvl1__Wrapper, file, num_trials, num_rows_per_sample);
                    //file.clear();
                }

                //this is not intuitive
                n_compound_solutions = compound_solutions.size();
                for(k = 0;k<n_compound_solutions; k++)
                {
                    compound_solutions.get(k).second().join(lvl0_left_solutions.get(i).second());
                    compound_solutions.get(k).second().join(lvl0_right_solutions.get(j).second());
                }

                concatenate(all_compound_solutions, compound_solutions);

                //predicate_lvl0_right.clear();
                predicate_lvl0_right = predicate_lvl0_right_original.clone();
            }

            //predicate_lvl0_left.clear();
            predicate_lvl0_left = predicate_lvl0_left_original.clone();
        }

        all_compound_solutions.sort();
        all_compound_solutions.reverse();

        ret = all_compound_solutions.get(0).second();
    }

    //predicate_lvl0_left.clear();
    predicate_lvl0_left = predicate_lvl0_left_original;
    //predicate_lvl0_right.clear();
    predicate_lvl0_right = predicate_lvl0_right_original;

    return ret;
}

Solver get_score(SketchFunction harness3, Solution solution, File file)
{
    SketchFunction program = harness3.produce_concretization(solution); // create a program that uses the solution to fill in the holes of the harness.
    int score2 = count_passing_inputs(program, file); // count how many input-output examples are solved with this solution
    program.clear();
    return score2;
}

/*

Solver Solution original_sketch_main()
{
    return beam_search_sketch_main();
    //return repeat_greedy_sketch_main();
    //return stun_main();
}

Solver Solution beam_search_sketch_main()
{
    //string file_name = "zig_zag.data";
    string file_name = "uav_kg_big__as_bools.data";
    //string file_name = "uav_kg_big__as_bools__smaller.data";

    File file = File(file_name, sketch_main_lvl0__Wrapper); //unnatural, remove harness
    int total_num_rows = file.size();

    int num_trials = 10;
    int num_rows_per_sample = 6;
    int beam_breath = 3;

    vector<pair<int, Solution> > best_effort_solutions =
        best_effort_solutions(sketch_main_lvl0__Wrapper, file, num_trials, num_rows_per_sample);

    vector<pair<int, pair<int, Solution> > > indexed_solutions = vector<pair<int, pair<int, Solution> > >();
    //use python syntax for arrays

    int best_effort_solutions_size = best_effort_solutions.size();
    pair<int, Solution> element;
    for(int i = 0; i<best_effort_solutions_size; i++)
    {
        element = best_effort_solutions.get(i);
        indexed_solutions.append(
            pair<int, pair<int, Solution> >(
                element.first(), pair<int, Solution>(0, element.second())));
    }

    indexed_solutions.sort();
    indexed_solutions.reverse();

    int num_candidates = indexed_solutions.size();
    SketchFunction harness4;
    vector<pair<int, pair<int, Solution> > > next_frontier = vector<pair<int, pair<int, Solution> > >();
    int local_n;
    int j;
    Solution tmp_solution;
    Solution partial_solution;
    SketchFunction throw_away;
    for(i = 0;i<beam_breath;i++)
    {
        harness4 = sketch_main_lvl1__Wrapper.clone();
        assert(indexed_solutions.get(i).second().first() == 0);
        partial_solution = indexed_solutions.get(i).second().second();
        harness4.concretize(partial_solution);
        file = File(file_name, harness4);
        best_effort_solutions = best_effort_solutions(harness4, file, num_trials, num_rows_per_sample);

        local_n = best_effort_solutions.size();

        for(j = 0;j<local_n;j++)
        {
            tmp_solution = partial_solution.clone();
            tmp_solution.join(best_effort_solutions.get(j).second());
            next_frontier.append(
                pair<int, pair<int, Solution> >(
                    best_effort_solutions.get(j).first(),
                    pair<int, Solution>(1, tmp_solution)));
        }
        harness4.clear();
    }


    next_frontier.sort();
    next_frontier.reverse();


    num_candidates = next_frontier.size();
    vector<pair<int, pair<int, Solution> > > final_frontier = vector<pair<int, pair<int, Solution> > >();
    int counter = 0;
    for(i = 0;i<beam_breath;i++)
    {
        harness4 = sketch_main_lvl2__Wrapper.clone();
        assert(next_frontier.get(i).second().first() == 1);
        partial_solution = next_frontier.get(i).second().second();
        harness4.concretize(partial_solution);
        file = File(file_name, harness4);
        best_effort_solutions = best_effort_solutions(harness4, file, num_trials, num_rows_per_sample);

        local_n = best_effort_solutions.size();

        for(j = 0;j<local_n;j++)
        {
            tmp_solution = partial_solution.clone();
            tmp_solution.join(best_effort_solutions.get(j).second());
            final_frontier.append(
                pair<int, pair<int, Solution> >(
                    best_effort_solutions.get(j).first(),
                    pair<int, Solution>(2, tmp_solution)));
            counter++;
            print("score ", best_effort_solutions.get(j).first(), " counter ", counter);
        }
        harness4.clear();
    }

    final_frontier.sort();
    final_frontier.reverse();

    assert(final_frontier.size() > 0);

    Solution ret_solution = final_frontier.get(0).second().second();

    return ret_solution;
}

Solver Solution repeat_greedy_sketch_main()
{
    string file_name = "zig_zag.data";
    File file = File(file_name, sketch_main_lvl2__Wrapper);
    int n = file.size();


    Solution sol = stun_main();
    int score = get_score(sketch_main_lvl2__Wrapper, sol, file);
    print("at_score ", score, "/", n);
    while(score < n)
    {
        seed++;
        sol = stun_main();
        score = get_score(sketch_main_lvl2__Wrapper, sol, file);
        print("at_score ", score, "/", n);
    }

    return sol;
}

*/

Solver stun_main()
{
	int num_trials = 20; //hyperparameter
	int num_rows = 6; //hyperparameter

    Solution total_solution = Solution();

    SketchFunction org_program_lvl0 = program_lvl0.clone();
    SketchFunction org_program_lvl1 = program_lvl1.clone();
    SketchFunction org_program_lvl2 = program_lvl2.clone();

    SketchFunction tmp_program_lvl0 = program_lvl0;
    SketchFunction tmp_program_lvl1 = program_lvl1;
    SketchFunction tmp_program_lvl2 = program_lvl2;

    program_lvl0 = org_program_lvl0;
    program_lvl1 = org_program_lvl1;
    program_lvl2 = org_program_lvl2;

	//solve the harness lvl0
	File file = File(file_name, main_lvl0__Wrapper); // The dataset is stored in a File; File is a native construct.
	print("main_lvl0__Wrapper.num_holes() = ", main_lvl0__Wrapper.num_holes());
	Solution solution_lvl0 = best_effort_synthesis(main_lvl0__Wrapper, file, num_trials, num_rows);
    total_solution.join(solution_lvl0);

	//concretize the predicate lvl0
	program_lvl0.concretize(solution_lvl0);

	//solve the harness lvl1
	file = File(file_name, main_lvl1__Wrapper);
	print("main_lvl1__Wrapper.num_holes() = ", main_lvl1__Wrapper.num_holes());
	Solution solution_lvl1 = best_effort_synthesis(main_lvl1__Wrapper, file, num_trials, num_rows);
    total_solution.join(solution_lvl1);

	//concretize the predicate lvl1
	program_lvl1.concretize(solution_lvl1);

	//solve the harness lvl2
	file = File(file_name, main_lvl2__Wrapper);
	print("main_lvl2__Wrapper.num_holes() = ", main_lvl2__Wrapper.num_holes());
	Solution solution_lvl2 = best_effort_synthesis(main_lvl2__Wrapper, file, num_trials, num_rows);
    total_solution.join(solution_lvl2);

	//concretize the predicate lvl2
	program_lvl2.concretize(solution_lvl2);

	//done, no more predicates to concretize.


    program_lvl0 = tmp_program_lvl0;
    program_lvl1 = tmp_program_lvl1;
    program_lvl2 = tmp_program_lvl2;

	return total_solution;
}

Solver best_effort_solutions(SketchFunction harness5, File file, int num_trials, int num_rows) {

	Solution best_solution;
	int best_score = 0;

    File subset_file;
    Solution solution;
    SketchFunction program;
    int score;

    vector<pair<int, Solution> > solutions = vector<pair<int, Solution> >();
    for(int trial_id = 0; trial_id<num_trials; trial_id++)
	{
		subset_file = file.produce_subset_file(num_rows); //sample subset of the rows
		solution = SATSolver(harness5.deep_clone(), subset_file); // invoke the Sketch Solver on the harness
		subset_file.clear();
		score = get_score(harness5, solution, file);
		print("TRIAL", trial_id+1, "/", num_trials, "SCORE", score, "/", file.size());
		solutions.append(pair<int, Solution>(score, solution));
		if(score > best_score) // update the best_solution
		{
			best_solution = solution;
			best_score = score;
		}
	}

	solutions.sort();
	solutions.reverse();

	print("Sorted solution scores:");

	int solutions_size = solutions.size();

    pair<int, Solution> element;
	for(int i = 0; i<solutions_size; i++)
	{
	    element = solutions.get(i);
	    print("count ", element.first(), "/", file.size(), "= (", ((float(100) * float(element.first())) / float(file.size())), "%)");
	}
	print("Done sorted solution scores");

	print("best_score = ", best_score);

    assert(solutions.size() == num_trials);

    print("ASSERTED TRUE:", "solutions.size()", solutions.size(), "num_trials", num_trials);

    return solutions;
}

Solver best_effort_synthesis(SketchFunction harness6, File file, int num_trials, int num_rows) {
    vector<pair<int, Solution> > solutions = best_effort_solutions(harness6, file, num_trials, num_rows);
    int solutions_size = solutions.size();
    Solution ret = solutions.get(0).second();
	return ret;
}

//subroutine to count the number of passing input-output examples.
Solver int count_passing_inputs(SketchFunction program, File file)
{
	int score = 0;
	int row_id = 0;
	int n = file.size();
    Input input;
    bool success;
	while(row_id < n){
	//for(int row_id = 0; row_id < file.size();i++){
	    input = file.get(row_id);
		success = program.passes(input);
		if(success == true){
		    score = score + 1;
		}
		row_id++;
	}
	print("count_passing_inputs returns", score);
	return score;
}

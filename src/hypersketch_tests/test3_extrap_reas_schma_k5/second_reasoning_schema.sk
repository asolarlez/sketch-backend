int n_io = 2;
int const_max_n = 4;
int const_k = 5;
int const_max_m = 16;

int get_2bit_id(int max_n, int ioro0, int x0, int ioro1, int x1, bit[max_n] input, bit[max_n] output){
    int id = 0;
    if(ioro0==0) {
        id+=input[x0];
    }
    else {
        id+=output[x0];
    }
    if(ioro1==0) {
        id+=2*input[x1];
    }
    else {
         id+=2*output[x1];
    }
    return id;
}

generator void learnable_primitive_schema(
    int max_num_ops, int op_id, int signature_size,
    int max_m, int max_n,
    int m, int n_in, int n_out,
    bit[max_n][max_m][n_io] bits,
    bit[max_n] input, ref bit[max_n] output, ref bit[max_n] output_mask, ref int num_done,
    ref int[signature_size][max_num_ops] signature)
{
    assert(op_id < max_num_ops);
    assert(signature_size >= 6);
    learnable_primitive(signature_size, max_m, max_n, m, n_in, n_out, bits, input, output, output_mask, num_done, signature[op_id]);
}

generator void learnable_primitive(
    int signature_size,
    int max_m, int max_n,
    int m, int n_in, int n_out,
    bit[max_n][max_m][n_io] bits,
    bit[max_n] input, ref bit[max_n] output, ref bit[max_n] output_mask, ref int num_done,
    ref int[signature_size] signature)
{
    assert(signature_size >= 6);
    /*assert(?? == signature_size);
    assert(?? == max_m);
    assert(?? == max_n);
    assert(?? == m);
    assert(?? == n_in);
    assert(?? == n_out);*/

    signature[5] = 1;
    int ioro0 = ??(1);
    signature[0] = ioro0;
    int x0 = ??;
    signature[1] = x0;
    if(ioro0 == 0) {
        assert(0 <= x0 && x0 < n_in);
    }
    else {
        assert(0 <= x0 && x0 < n_out-1);
        assert(output_mask[x0] == 1);
    }
    int ioro1 = ??(1);
    signature[2] = ioro1;
    int x1 = ??;
    signature[3] = x1;
    if(ioro1 == 0) {
        assert(ioro0 == 0);
        assert(x0 <= x1 && x1 < n_in);
    }
    else {
        if(ioro0 == 1) {
            assert(x0 <= x1);
        }
        assert(0 <= x1 && x1 < n_out);
        assert(output_mask[x1] == 1);
    }
    int y = ??;
    signature[4] = y;
    assert(0 <= y && y < n_out);
    assert(output_mask[y] == 0);

    int num_ids = 4;
    bit[num_ids] undetermined;
    bit[num_ids] seen;
    bit[num_ids] table;
    for(int i = 0;i<m;i++) {
        int id = get_2bit_id(max_n, ioro0, x0, ioro1, x1, bits[0][i], bits[1][i]);
        if(seen[id] == 1) {
            if(table[id] != bits[1][i][y]) {
                undetermined[id] = 1;
            }
        }
        else {
            seen[id] = 1;
            table[id] = bits[1][i][y];
        }
    }

    bit[num_ids] _seen = {??, ??, ??, ??};
    bit[num_ids] _undetermined = {??, ??, ??, ??};
    bit[num_ids] _table = {??, ??, ??, ??};
    for(int i = 0; i < num_ids;i++) {
        assert(_seen[i] == seen[i]);
        assert(_undetermined[i] == undetermined[i]);
        assert(_table[i] == table[i]);
    }

    int id = get_2bit_id(max_n, ioro0, x0, ioro1, x1, input, output);

    if(undetermined[id] == 0) {
        output_mask[y] = 1;
        num_done += 1;
        output[y] = table[id];
    }
}

void learning_noop(
    int max_num_ops, int op_id, int signature_size,
    int max_m, int max_n,
    int m, int n_in, int n_out,
    bit[max_n][max_m][n_io] bits,
    bit[max_n] input, ref bit[max_n] output, ref bit[max_n] output_mask, ref int num_done,
    ref int[signature_size][max_num_ops] signature) {
    assert(op_id < max_num_ops);
    for(int i = 0;i<signature_size;i++) {
        signature[op_id][i] = 0;
    }
}

generator void reasoning_schema(
    int max_num_ops, int op_id, int signature_size,
    int max_m, int max_n,
    int m, int n_in, int n_out,
    bit[max_n][max_m][n_io] bits,
    bit[max_n] input, ref bit[max_n] output, ref bit[max_n] output_mask, ref int num_done,
    ref int[signature_size][max_num_ops] signature) {
    assert(op_id < max_num_ops);
    /*assert(?? == signature_size);
    assert(?? == max_m);
    assert(?? == max_n_in);
    assert(?? == max_n_out);
    assert(?? == n_in);
    assert(?? == n_out);
    assert(?? == op_id);
    assert(?? == num_done);*/
    if(num_done < n_out && op_id < n_out) {
        learnable_primitive(signature_size, max_m, max_n, m, n_in, n_out, bits, input, output, output_mask, num_done, signature[op_id]);
        int next_op_id = op_id+1;
        if(num_done < n_out && next_op_id < n_out) {
            reasoning_schema(
                max_num_ops, next_op_id, signature_size,
                max_m, max_n,
                m, n_in, n_out, bits,
                input, output, output_mask, num_done, signature);
        } else {
            assert(?? == num_done);
            assert(?? == next_op_id);
            assert(?? == n_out);
        }
    }
}

generator void train_reasoning_schema(
    int max_num_ops, int signature_size,
    int max_m, int max_n,
    int m, int n_in, int n_out,
    bit[max_n][max_m][n_io] bits,
    ref int[signature_size][max_num_ops] signature) {
    for(int i = 0;i<m;i++){
        bit[max_n] output;
        bit[max_n] output_mask;
        int num_done = 0;
        int op_id = 0;

        reasoning_schema(
            max_num_ops, op_id, signature_size,
            max_m, max_n,
            m, n_in, n_out,
            bits,
            bits[0][i], output, output_mask, num_done,
            signature);

        assert(num_done == n_out);
        for(int j = 0;j<n_out;j++) {
            assert(output[j] == bits[1][i][j]);
        }
    }
}

void train_rs0(int max_num_ops, int signature_size, int max_m, int max_n, int m, int n_in, int n_out, bit[max_n][max_m][n_io] bits, ref int[signature_size][max_num_ops] signature) {
    return train_reasoning_schema(max_num_ops, signature_size, max_m, max_n, m, n_in, n_out, bits, signature);
}

void train_rs1(int max_num_ops, int signature_size, int max_m, int max_n, int m, int n_in, int n_out, bit[max_n][max_m][n_io] bits, ref int[signature_size][max_num_ops] signature) {
    return train_reasoning_schema(max_num_ops, signature_size, max_m, max_n, m, n_in, n_out, bits, signature);
}

void train_rs2(int max_num_ops, int signature_size, int max_m, int max_n, int m, int n_in, int n_out, bit[max_n][max_m][n_io] bits, ref int[signature_size][max_num_ops] signature) {
    return train_reasoning_schema(max_num_ops, signature_size, max_m, max_n, m, n_in, n_out, bits,signature);
}

void train_rs3(int max_num_ops, int signature_size, int max_m, int max_n, int m, int n_in, int n_out, bit[max_n][max_m][n_io] bits, ref int[signature_size][max_num_ops] signature) {
    return train_reasoning_schema(max_num_ops, signature_size, max_m, max_n, m, n_in, n_out, bits,signature);
}

void train_rs4(int max_num_ops, int signature_size, int max_m, int max_n, int m, int n_in, int n_out, bit[max_n][max_m][n_io] bits, ref int[signature_size][max_num_ops] signature) {
    return train_reasoning_schema(max_num_ops, signature_size, max_m, max_n, m, n_in, n_out, bits,signature);
}

generator void k3_ers(
    int k, int i,
    int max_num_ops, int signature_size,
    int max_m, int max_n,
    int[k] ms, int[k] n_ins, int[k] n_outs,
    bit[max_n][max_m][n_io][k] bits,
    ref int[signature_size][max_num_ops][k] signature)  {
    i = 0;
    //5920; with --bnd-arr-size 232 --bnd-unroll-amnt 16 --bnd-inline-amnt 2 --bnd-inbits 4
    //train_rs0(max_num_ops, signature_size, max_m, max_n, ms[i], n_ins[i], n_outs[i], bits[i], signature[i]);
    i = i+1;
    //5866
    //train_rs1(max_num_ops, signature_size, max_m, max_n, ms[i], n_ins[i], n_outs[i], bits[i], signature[i]);
    i = i+1;
    //5985
    //train_rs2(max_num_ops, signature_size, max_m, max_n, ms[i], n_ins[i], n_outs[i], bits[i], signature[i]);
    i = i+1;
    //6115
    //train_rs3(max_num_ops, signature_size, max_m, max_n, ms[i], n_ins[i], n_outs[i], bits[i], signature[i]);
    i = i+1;
    //9032; --bnd-arr-size 232 --bnd-unroll-amnt 16 --bnd-inline-amnt 3 --bnd-cbits 2 --fe-keep-tmp -V3
    train_rs4(max_num_ops, signature_size, max_m, max_n, ms[i], n_ins[i], n_outs[i], bits[i], signature[i]);
}

/*generator void extrapolatable_reasoning_schema(
    int k, int i,
    int max_num_ops, int signature_size,
    int max_m, int max_n,
    int[k] ms, int[k] n_ins, int[k] n_outs,
    bit[max_n][max_m][n_io][k] bits,
    ref int[signature_size][max_num_ops][k] signature)
{
    train_reasoning_schema(
        max_num_ops, signature_size,
        max_m, max_n,
        ms[i], n_ins[i], n_outs[i], bits[i]
        signature[i]
    );
    if(i+1 < k) {
        extrapolatable_reasoning_schema(k, i+1,
            max_num_ops, signature_size,
            max_m, max_n,
            ms, n_ins, n_outs,
            bits,
            signature
        );
    }
}*/

int max(int a, int b)
{
    if(a > b)
    {
        return a;
    }
    return b;
}

@FromFile("gammaexample.data") // meta-examples across n.
harness void sketch_main(
    int n_vecspec, int n_rawbits,
    int k, int max_m, int max_n,
    int[k] ms, int[k] n_ins, int[k] n_outs,
    int[4][n_vecspec] vecspecs, bit[n_rawbits] raw_bits)
{
    /*
    int[4][10] _vecspecs = ??;
    assert(_vecspecs == vecspecs);
    bit[14] _raw_bits = ??;
    assert(_raw_bits == raw_bits);
    */

    assert(max_n == const_max_n);

    bit[max_n][max_m][n_io][k] bits;
    int at_raw_bit_id = 0;
    int const_n_vecspec = 58;
    for(int i = 0;i<const_n_vecspec;i++) {
        int kid = vecspecs[i][0];
        int ioro = vecspecs[i][1];
        int mid = vecspecs[i][2];
        int n = vecspecs[i][3];
        int j = 0;
        assert(n <= max_n);
        repeat(const_max_n) {
            if(at_raw_bit_id < n_rawbits) {
                if(j < n) {
                    bits[kid][ioro][mid][j] = raw_bits[at_raw_bit_id++];
                    j++;
                }
            }
            else {
                assert(j>=n && i == n_vecspec-1);
            }
        }
    }


    assert(const_k == k);
    assert(const_max_m == max_m);

    /*
    //Need more unrolling bc of flattened length of arrays.
    repeat(i : const_k) {
        bit[const_max_n][const_max_m] _inbits = ??;
        bit[const_max_n][const_max_m] _outbits = ??;
        assert(_inbits == bits[i][0]);
        assert(_outbits ==  bits[i][1]);
    }*/
    int max_op_fan_in = 2;
    int op_fan_out = 1;
    int signature_size = 2+max_op_fan_in+op_fan_out+1; //+2 for i/o destinction for 2 fanin; +1 for noop bit.
    int max_num_ops = k;
    int i = 0;
    int[signature_size][max_num_ops][k] signature;
    k3_ers(
        k, i,
        max_num_ops, signature_size,
        max_m, max_n, ms, n_ins, n_outs, bits,
        signature);

    /*extrapolatable_reasoning_schema(
        k, i,
        max_num_ops, signature_size,
        max_m, max_n, ms, n_ins, n_outs, bits,
        signature
    );*/
}
